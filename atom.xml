<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>逸思杂陈</title>
  <icon>https://www.gravatar.com/avatar/071e91e4d2b41eefac3330385d124f95</icon>
  <subtitle>人类一思考，上帝就发笑。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ponder.work/"/>
  <updated>2021-08-03T08:29:43.102Z</updated>
  <id>http://ponder.work/</id>
  
  <author>
    <name>Jay.Run</name>
    <email>ruan.lj@foxmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 iTerm2 管理 Tmux 会话</title>
    <link href="http://ponder.work/2021/08/02/media/iterm2-tmux-integration/"/>
    <id>http://ponder.work/2021/08/02/media/iterm2-tmux-integration/</id>
    <published>2021-08-02T12:00:00.000Z</published>
    <updated>2021-08-03T08:29:43.102Z</updated>
    
    <content type="html"><![CDATA[<p>Tmux 是一个终端复用器（terminal multiplexer），非常有用，属于常用的开发工具。</p><p>Tmux 可以维持和管理我们的远程终端会话，和服务断线重连后也不会丢失工作状态, 同时可以在一个终端连接中开启多个窗口（window）和窗格（pane）。</p><p>一个典型的例子就是，SSH 登录远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。<br><a id="more"></a><br>比如，下面就包含了2个窗口和3个窗格<br><img src="http://image.runjf.com/mweb/2021-08-03-16279763351692.jpg" alt></p><p>具体 Tmux 的细节和使用可以参考 <a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html" target="_blank" rel="noopener">阮一峰的文章</a></p><p>但是 Tmux 也存在以下几个问题（个人观点）</p><ol><li>窗口和会话管理默认是全键盘操作，需要记比较多快捷键</li><li>由于窗口是 Tmux 虚拟的, 不支持文本回滚（scrollback），文本复制不完美</li><li>不支持rzsz</li></ol><p>而 iTerm2 内置了 Tmux 绑定功能，可以将 tmux 的窗口和窗格映射成原生的窗口和窗格，可以用 iTerm2 的菜单和快捷键来操作窗口。<br>rzsz 由于 tmux 的实现机制决定了是无解的。</p><h2 id="iTerm2-配置"><a href="#iTerm2-配置" class="headerlink" title="iTerm2 配置"></a>iTerm2 配置</h2><p>可以对 tmux 窗口的映射进行一些定制</p><p>iTerm2 对于 tmux 会话有一个profile，建议对终端颜色和外观进行一些定制化，将原生窗口和 tmux 窗口区分开来。</p><p><img src="http://image.runjf.com/mweb/2021-08-03-16279767130639.jpg" alt><br><img src="http://image.runjf.com/mweb/2021-08-03-16279767560503.jpg" alt></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>对于终端机器的 Tmux 版本有要求，需要支持<code>-CC</code>命令</p><p><strong>具体方法</strong></p><ul><li>新建窗口: <code>tmux -CC</code></li><li>断开重连(attach): <code>tmux -CC attach</code></li><li>断开连接(dettach): 在连接的窗口按 esc，或者直接关掉连接的 tab 吧</li><li>关掉 session(destroy): 关闭当前 session 的所有 tab 即可</li></ul><p>还可以使用 iTerm 的 tmux dashboard 来管理多个会话。</p><p><img src="http://image.runjf.com/mweb/2021-08-03-16279791270158.jpg" alt></p><p><img src="http://image.runjf.com/mweb/2021-08-03-16279791503013.jpg" alt></p><p><img src="http://image.runjf.com/mweb/2021-08-03-16279775548246.jpg" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2019/10/tmux.html</a></li><li><a href="https://www.v2ex.com/t/589453" target="_blank" rel="noopener">https://www.v2ex.com/t/589453</a></li><li><a href="https://iterm2.com/documentation-tmux-integration.html" target="_blank" rel="noopener">https://iterm2.com/documentation-tmux-integration.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tmux 是一个终端复用器（terminal multiplexer），非常有用，属于常用的开发工具。&lt;/p&gt;
&lt;p&gt;Tmux 可以维持和管理我们的远程终端会话，和服务断线重连后也不会丢失工作状态, 同时可以在一个终端连接中开启多个窗口（window）和窗格（pane）。&lt;/p&gt;
&lt;p&gt;一个典型的例子就是，SSH 登录远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。&lt;br&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://ponder.work/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="tmux" scheme="http://ponder.work/tags/tmux/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制机制</title>
    <link href="http://ponder.work/2021/07/21/redis-master-slave/"/>
    <id>http://ponder.work/2021/07/21/redis-master-slave/</id>
    <published>2021-07-21T14:48:00.000Z</published>
    <updated>2021-07-25T09:57:05.948Z</updated>
    
    <content type="html"><![CDATA[<p>Redis作为内存型数据，为了高可用，必须有数据备份，这里采取主从的模式。<br>用户可以通过执行 SLAVEOF 命令或者设置 slaveof 选项，让一个服务器去复制 （replicate) 另一个服务器。<br><a id="more"></a><br>如果服务器 <code>127.0.0.1:12345</code> 向 <code>127.0.0.1:6379</code> 发送 <code>SLAVEOF 127.0.0.1 6379</code>, 则服务器（12345）将成为服务器（6379）的从服务器。</p><h2 id="旧版复制功能（全量复制）"><a href="#旧版复制功能（全量复制）" class="headerlink" title="旧版复制功能（全量复制）"></a>旧版复制功能（全量复制）</h2><p>Redis的复制功能分为同步（RDB文件）和命令传播（同步写命令）两个阶段，具体步骤如下。</p><ol><li>从服务器发送<code>SYNC</code></li><li>主服务器接收<code>SYNC</code>后执行<code>BGSAVE</code>生成RDB文件，同时用缓冲区记录之后所有写命令。</li><li>主服务器发送RDB到从服务器，从服务器加载RDB</li><li>主服务器发送缓冲区内的写命令</li><li>之后主服务器写命令都需要同时发一份给从服务器（命令传播）</li></ol><p><img src="http://image.runjf.com/mweb/2021-07-25-16272051223635.jpg" alt="-w908"></p><h2 id="缺陷及解决方案"><a href="#缺陷及解决方案" class="headerlink" title="缺陷及解决方案"></a>缺陷及解决方案</h2><p>由于RDB的生成发送非常耗时，主从短暂断线的情况下，也需要重复生成，主从同步的效率就非常低了。</p><p>Redis从2.8版本开始, 使用<code>PSYNC</code>命令替换<code>SYNC</code>，增加了部分同步功能，对断线重连的情况进行了优化。</p><p>主从服务器都记录了<strong>复制偏移量</strong>，记录了主服务器发出的字节数和从服务器收到的字节数,并且主服务器使用一个<strong>复制积压缓冲区</strong>记录最近发出的数据（FIFO）。</p><p>同步时，从服务器会发送复制偏移量。</p><ul><li>如果，主从偏移量相差的这部分数据在缓冲区中，则主服务器就发送这部分数据</li><li>否则，执行全量复制。</li></ul><p>同时，主服务器每次启动时会生成<strong>运行id</strong>，防止主服务器重启后复制混乱。</p><p><img src="http://image.runjf.com/mweb/2021-07-25-16272066103593.jpg" alt="-w586"><br><img src="http://image.runjf.com/mweb/2021-07-25-16272066397939.jpg" alt="-w552"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>redis 3.0 源码</li><li>redis 设计与实现</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis作为内存型数据，为了高可用，必须有数据备份，这里采取主从的模式。&lt;br&gt;用户可以通过执行 SLAVEOF 命令或者设置 slaveof 选项，让一个服务器去复制 （replicate) 另一个服务器。&lt;br&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://ponder.work/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Redis" scheme="http://ponder.work/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化：RDB与AOF</title>
    <link href="http://ponder.work/2021/07/20/redis-source-code-rdb-aof-persistence/"/>
    <id>http://ponder.work/2021/07/20/redis-source-code-rdb-aof-persistence/</id>
    <published>2021-07-20T14:48:00.000Z</published>
    <updated>2021-07-21T11:13:54.281Z</updated>
    
    <content type="html"><![CDATA[<p>Redis是内存型数据库，所有数据都存储在内存中。而内存是易失型存储，一旦进程退出所有数据都会丢失。</p><p>所谓持久化，就是将Redis在内存中的数据库状态以某次格式保存到磁盘里面，避免数据意外丢失。</p><p>Redis有两种持久化方式：RDB (Redis Database)、AOF (Append Only File)<br><a id="more"></a></p><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，包含了Redis数据库的所有数据。</p><p>RDB是将redis中所有db中的所有键值对以如下格式进行储存</p><p><img src="http://image.runjf.com/mweb/2021-07-21-16268563558568.jpg" alt></p><h3 id="RDB文件创建"><a href="#RDB文件创建" class="headerlink" title="RDB文件创建"></a>RDB文件创建</h3><p>有两个命令可以生成RDB文件，<code>SAVE</code> 和 <code>BGSAVE</code>。生成RDB文件时，redis会遍历所有非空db的所有键值对按一定格式存储到RDB文件中。</p><p><code>SAVE</code> 命令会在当前进程进行，期间服务器会阻塞，不能处理任何请求。<br><code>BGSAVE</code> 命令会fork一个子进程来创建RDB（利用Copy-on-write），服务继续处理命令请求。</p><p>为了避免竞争条件和性能问题，<code>SAVE</code> 和 <code>BGSAVE</code>任意时刻只能有一个在执行。</p><p>用户可以通过save选项设置多个保存条件,但只要其中任意一个条件被满足，就会触发RDB保存.<br>save选项的格式是 <code>save seconds option_times</code>。例如<code>save 900 1</code>，若服务器在900秒之内, 对数据库进行了至少1次修改，则执行BGSAVE。</p><h3 id="RDB文件读取"><a href="#RDB文件读取" class="headerlink" title="RDB文件读取"></a>RDB文件读取</h3><p>服务器启动时会自动载入RDB文件，Redis并没有专门用于载人RDB文件的命令。</p><p>如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。</p><h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>由于RDB生成的机制决定了，RDB文件总是会和redis内存有部分不一致，<strong>RDB文件会缺少从上次BGSAVE开始到当前时刻的所有改动</strong>。AOF持久化的存在就是为了解决该问题。</p><p>AOF持久化是通过保存执行的写命令来记录数据库状态。<br>因为Redis的命令请求协议是纯文本格式，所以AOF文件类似如下。<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*2<span class="tag">\<span class="name">r</span></span><span class="tag">\<span class="name">n</span></span><span class="formula">$6<span class="tag">\<span class="name">r</span></span><span class="tag">\<span class="name">nSELECT</span></span><span class="tag">\<span class="name">r</span></span><span class="tag">\<span class="name">n</span></span>$</span>l<span class="tag">\<span class="name">r</span></span><span class="tag">\<span class="name">nO</span></span><span class="tag">\<span class="name">r</span></span><span class="tag">\<span class="name">n</span></span> </span><br><span class="line">*3<span class="tag">\<span class="name">r</span></span><span class="tag">\<span class="name">n</span></span><span class="formula">$3<span class="tag">\<span class="name">r</span></span><span class="tag">\<span class="name">nSET</span></span><span class="tag">\<span class="name">r</span></span><span class="tag">\<span class="name">n</span></span>$</span>3<span class="tag">\<span class="name">r</span></span><span class="tag">\<span class="name">nmsg</span></span><span class="tag">\<span class="name">r</span></span><span class="tag">\<span class="name">n</span></span><span class="formula">$5<span class="tag">\<span class="name">r</span></span><span class="tag">\<span class="name">nhello</span></span><span class="tag">\<span class="name">r</span></span><span class="tag">\<span class="name">n</span></span></span></span><br></pre></td></tr></table></figure></p><h3 id="AOF持久化实现"><a href="#AOF持久化实现" class="headerlink" title="AOF持久化实现"></a>AOF持久化实现</h3><ol><li>命令追加：执行完命令，将所有<strong>写命令</strong>追加到aof_buf缓冲区末尾</li><li>文件写入：将aof_buf的内容写入文件，并清空aof_buf</li><li>文件同步：清空完aof_buf之后，根据appendfsync配置的策略，决定如何刷新文件缓存到硬盘。</li></ol><p>appendfsync决定如何刷新文件缓存到硬盘，该选项的值直接影响的效率和安全性。<br>当故障停机时，文件缓冲区内的数据会丢失。<br>appendfsync有以下选项</p><ul><li>always: 每次都会进行文件缓冲区刷新，最安全，效率也最低。</li><li>no: 不主动刷新文件缓冲区，由系统决定刷新时机，安全性最低，效率最高</li><li>everysec: 每秒刷新一次文件缓冲区，安全性和效率的折中方案。</li></ul><h3 id="AOF文件还原"><a href="#AOF文件还原" class="headerlink" title="AOF文件还原"></a>AOF文件还原</h3><p>AOF的还原就是模仿客户端逐条执行文件里的命令。</p><p>AOF的还原时机也是服务启动时，并且在还原过程中能正常执行的只有 PUBSUB 等模块。</p><p>步骤如下：</p><ol><li>创建不带网络连接的伪客户端(fake client)</li><li>从AOF文件中分析和读取一条命令</li><li>使用伪客户端执行该命令</li><li>重复步骤2、3，直到处理完所有命令</li></ol><h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>由于AOF是直接记录的写命令而不是数据库状态，所以文件中包含很多冗余语句，导致文件膨胀。</p><p>比如下面的这些命令，其实最终数据库状态等价于<code>lpush numbers 333</code>, 前4条语句都是冗余的。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">lpush</span> <span class="selector-tag">numbers</span> 111</span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">lpush</span> <span class="selector-tag">numbers</span> 222</span><br><span class="line">(<span class="selector-tag">integer</span>) 2</span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">lpop</span> <span class="selector-tag">numbers</span></span><br><span class="line">"222"</span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">lpop</span> <span class="selector-tag">numbers</span></span><br><span class="line">"111"</span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">lpush</span> <span class="selector-tag">numbers</span> 333</span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">lrange</span> <span class="selector-tag">numbers</span> 0 <span class="selector-tag">-1</span></span><br><span class="line">1) "333"</span><br></pre></td></tr></table></figure></p><p>为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写(rewrite) 功能。</p><p>AOF文件重写是遍历redis的所有键值对，生成对应的redis命令，写入到一个新的文件中，并替换旧AOF文件。<br>所以AOF文件重写和旧AOF文件并没有关系，更应该称之为<strong>AOF重生成</strong>。</p><p>AOF重写程序在子进程里执行, 这样做可以同时达到两个目的: </p><ul><li>子进程进行AOF重写期间, 服务器进程可以继续处理命令请求。</li><li>子进程带有服务器进程的数据副本，可以在避免使用锁的情况下，保证数据的安全性（Copy-on-write）。</li></ul><p>在AOF重新过程中，所有命令会额外会写一份到<strong>AOF重写缓冲区</strong>中，当新AOF文件生成时，父进程会将AOF重写缓冲区的内容追加到新AOF文件中，并替换旧AOF文件。</p><p><img src="http://image.runjf.com/mweb/2021-07-21-16268637141893.jpg" alt></p><p>为防止AOF重写失败，AOF缓冲区在重写过程中依然正常工作。</p><p><img src="http://image.runjf.com/mweb/2021-07-21-16268635658876.jpg" alt></p><p><strong>注意</strong>：redis主从是基于<code>RDB + 命令传播</code>，并没有利用AOF文件，与MySQL的binlog不同。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>redis 3.0 源码</li><li>redis 设计与实现</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis是内存型数据库，所有数据都存储在内存中。而内存是易失型存储，一旦进程退出所有数据都会丢失。&lt;/p&gt;
&lt;p&gt;所谓持久化，就是将Redis在内存中的数据库状态以某次格式保存到磁盘里面，避免数据意外丢失。&lt;/p&gt;
&lt;p&gt;Redis有两种持久化方式：RDB (Redis Database)、AOF (Append Only File)&lt;br&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://ponder.work/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Redis" scheme="http://ponder.work/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>数独与回溯法</title>
    <link href="http://ponder.work/2021/07/10/sodoku-and-backtracking/"/>
    <id>http://ponder.work/2021/07/10/sodoku-and-backtracking/</id>
    <published>2021-07-10T11:48:00.000Z</published>
    <updated>2021-07-15T08:02:44.053Z</updated>
    
    <content type="html"><![CDATA[<p>数独是一种数学逻辑游戏，游戏由9×9个格子组成，玩家需要根据格子提供的数字推理出其他格子的数字。游戏设计者会提供最少17个数字使得解答谜题只有一个答案。</p><p>数独的解法需 遵循如下规则：</p><ol><li>数字 1-9 在每一行只能出现一次。</li><li>数字 1-9 在每一列只能出现一次。</li><li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。<a id="more"></a><img src="http://image.runjf.com/mweb/2021-07-11-16259930856620.jpg" alt="-w285"></li></ol><p>虽然玩法简单，但提供的数字却千变万化，所以很适合用程序来求解。</p><p>类似这种需要穷举的问题一般采用回溯法，也就是暴力求解，在最坏的情况下时间复杂度为指数。</p><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p>回溯法采用试错的思想，它尝试分步的去解决一个问题。在解决问题的过程中，如果现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。</p><p>回溯法通常用最简单的递归方法来实现，下面是回溯法的一般结构。<br>理解回溯法首先要理解递归，理解递归的过程，以及递归的返回值。可以通过查看斐波那契数列的递归实现的调用栈来理解递归的过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking</span><span class="params">(args)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> can_stop(args):  <span class="comment"># 判断是否终止，限制了递归深度</span></span><br><span class="line">        <span class="keyword">if</span> need():   <span class="comment"># 必要时收集递归子树的叶子节点的结果</span></span><br><span class="line">            collect_result()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> choice <span class="keyword">in</span> get_all_choices(args):  <span class="comment"># 针对每一种情况, 情况的个数也就是每一层的广度</span></span><br><span class="line">        set_state(args, choice)  <span class="comment"># 暂时选择该项</span></span><br><span class="line">        process(args)   <span class="comment"># 该节点数据加工</span></span><br><span class="line">        backtracking(args)   <span class="comment"># 递归进入下一层次</span></span><br><span class="line">        revert_state(args, choice)   <span class="comment"># 撤销当前选择</span></span><br></pre></td></tr></table></figure><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>回到数独解法上来</p><p>首先看最简单的暴力解法</p><p>这里有几个点和模板不一样</p><ul><li>由于把整个棋盘都填满游戏就终止了，所以不需要<code>can_stop</code>判断</li><li>每层递归会填满一个空位，递归的最大深度就是空位的个数。</li><li>数独棋盘都填满才算一个解，所以每层递归<code>get_all_choices</code>最多有 <code>行 x 列 x 数字取值 = 9 x 9 x 9</code> 种情况</li><li>由于数独规则的约束，行、列、九宫格内数字不能重复，所以天然有部分剪枝</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0 代表空位</span></span><br><span class="line">board = [</span><br><span class="line">    [<span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">EMPTY = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sodoku</span><span class="params">(board)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">can_put</span><span class="params">(board, row, col, c)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">if</span> board[i][col] != EMPTY <span class="keyword">and</span> board[i][col] == c:  <span class="comment"># 行不冲突</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> board[row][i] != EMPTY <span class="keyword">and</span> board[row][i] == c:  <span class="comment"># 列不冲突</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            x, y = row // <span class="number">3</span> * <span class="number">3</span> + i // <span class="number">3</span>,  col // <span class="number">3</span> * <span class="number">3</span> + i % <span class="number">3</span></span><br><span class="line">            <span class="keyword">if</span> board[x][y] != EMPTY <span class="keyword">and</span> board[x][y] == c:  <span class="comment"># 九宫不冲突</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(board)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == EMPTY:</span><br><span class="line">                    <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">                        <span class="keyword">if</span> can_put(board, i, j, c):</span><br><span class="line">                            board[i][j] = c</span><br><span class="line">                            <span class="keyword">if</span> solve(board):</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                            <span class="keyword">else</span>:</span><br><span class="line">                                board[i][j] = EMPTY</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> solve(board)</span><br></pre></td></tr></table></figure><h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><p>所谓的剪枝，就是递归每一层的时候，并不是所有情况都是有效的，可以跳过这些分支。</p><p><img src="http://image.runjf.com/mweb/2021-07-11-16260036519609.jpg" alt="-w351"></p><p>以该题为例，第一行第三列可选取值并不是1到9，而是<code>1，2，4</code>，而且随着我们不断把空位填满，越后面的点选择越少。<br>可以用集合存储每个空位的行、列、九宫方向的可选值，三者交集就是该点的可选值。（用位替换集合还可以进一步优化算法）<br>因为填充一个空位，会影响该位置行、列、九宫上的所有空位的取值，所有不直接存储该点的可选值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">EMPTY = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sodoku</span><span class="params">(board)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(board)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">                box_index = (i // <span class="number">3</span> ) * <span class="number">3</span> + j // <span class="number">3</span></span><br><span class="line">                <span class="keyword">if</span> board[i][j] == EMPTY:</span><br><span class="line">                    <span class="keyword">for</span> c <span class="keyword">in</span> (rows[i] &amp; columns[j] &amp; boxes[box_index]):    <span class="comment"># 通过集合来剪枝</span></span><br><span class="line">                        <span class="comment"># 设置状态</span></span><br><span class="line">                        board[i][j] = c</span><br><span class="line">                        tmp = [<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>]</span><br><span class="line">                        <span class="keyword">for</span> idx, elem <span class="keyword">in</span> enumerate((rows[i], columns[j], boxes[box_index])):</span><br><span class="line">                            <span class="keyword">if</span> c <span class="keyword">in</span> elem:</span><br><span class="line">                                elem.remove(c)</span><br><span class="line">                                tmp[idx] = <span class="literal">True</span></span><br><span class="line">                        <span class="comment"># 进入下一层递归</span></span><br><span class="line">                        <span class="keyword">if</span> solve(board):</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                        <span class="comment"># 还原状态</span></span><br><span class="line">                        board[i][j] = EMPTY</span><br><span class="line">                        <span class="keyword">for</span> idx, elem <span class="keyword">in</span> zip(tmp, (rows[i], columns[j], boxes[box_index])):</span><br><span class="line">                            <span class="keyword">if</span> idx:</span><br><span class="line">                                elem.add(c)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 验证题目是否合法, 初始化每一格可选择项</span></span><br><span class="line">    rows = [set(range(<span class="number">1</span>,<span class="number">10</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>)]  <span class="comment"># 行内所有点的可选值</span></span><br><span class="line">    columns = [set(range(<span class="number">1</span>,<span class="number">10</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>)]  <span class="comment"># 列</span></span><br><span class="line">    boxes = [set(range(<span class="number">1</span>,<span class="number">10</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>)]  <span class="comment"># 九宫</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            num = board[i][j]</span><br><span class="line">            <span class="keyword">if</span> num != EMPTY:</span><br><span class="line">                num = int(num)</span><br><span class="line">                box_index = (i // <span class="number">3</span> ) * <span class="number">3</span> + j // <span class="number">3</span></span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> rows[i]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                rows[i].remove(num)</span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> columns[j]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                columns[j].remove(num)</span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> boxes[box_index]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                boxes[box_index].remove(num)</span><br><span class="line">    <span class="keyword">return</span> solve(board)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E7%8D%A8" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%95%B8%E7%8D%A8</a><br><a href="https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF%E6%B3%95" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF%E6%B3%95</a><br><a href="https://www.jianshu.com/p/8e694d079a76" target="_blank" rel="noopener">https://www.jianshu.com/p/8e694d079a76</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数独是一种数学逻辑游戏，游戏由9×9个格子组成，玩家需要根据格子提供的数字推理出其他格子的数字。游戏设计者会提供最少17个数字使得解答谜题只有一个答案。&lt;/p&gt;
&lt;p&gt;数独的解法需 遵循如下规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数字 1-9 在每一行只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 1-9 在每一列只能出现一次。&lt;/li&gt;
&lt;li&gt;数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
    
    </summary>
    
    
      <category term="编程" scheme="http://ponder.work/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://ponder.work/tags/Python/"/>
    
      <category term="算法" scheme="http://ponder.work/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="回溯法" scheme="http://ponder.work/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>缓存淘汰算法之LFU</title>
    <link href="http://ponder.work/2021/06/23/lfu-cache/"/>
    <id>http://ponder.work/2021/06/23/lfu-cache/</id>
    <published>2021-06-23T14:48:00.000Z</published>
    <updated>2021-07-15T08:02:44.041Z</updated>
    
    <content type="html"><![CDATA[<p>Least Frequently Used (LFU) 是一种常见的缓存淘汰算法，译为“最近最不经常使用”，也就是将缓存中使用次数最少的数据淘汰掉。</p><p>有两种常见的实现方法</p><ul><li>小顶堆 + hashmap，插入和删除的复杂度为O(logN), 但淘汰相同访问次数的节点是不稳定的，因为堆排序不稳定。</li><li>数组存储数据项 + hashmap记录数据项index, 淘汰缓存的复杂度为O(N)</li></ul><a id="more"></a><p>特点</p><ol><li>一般情况下，LFU效率要优于LRU，且能够避免周期性或者偶发性的操作导致缓存命中率下降的问题</li><li>LFU存在历史数据影响将来数据的”缓存污染”问题。</li></ol><h2 id="Python-实现"><a href="#Python-实现" class="headerlink" title="Python 实现"></a>Python 实现</h2><p>这里的Python实现是方案1</p><p>具体步骤</p><ol><li>get元素时，如果存在则返回结果并更新访问次数</li><li>set元素时，如果存在则更新val并更新访问次数，否则检查是否淘汰缓存并插入新key</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">from math import log, ceil</span><br><span class="line"></span><br><span class="line">class MinHeap(object):</span><br><span class="line">    def __init__(<span class="keyword">self</span>):</span><br><span class="line">        <span class="keyword">self</span>._items = [<span class="literal">None</span>]</span><br><span class="line">        <span class="keyword">self</span>.need_swap = <span class="keyword">self</span>.more</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def length(<span class="keyword">self</span>):</span><br><span class="line">        <span class="keyword">return</span> len(<span class="keyword">self</span>._items) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def depth(<span class="keyword">self</span>):</span><br><span class="line">        <span class="keyword">return</span> ceil(log(<span class="keyword">self</span>.length+<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    def more(<span class="keyword">self</span>, i, j):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._items[i] &gt; <span class="keyword">self</span>._items[j]</span><br><span class="line"></span><br><span class="line">    def exch(<span class="keyword">self</span>, i, j):</span><br><span class="line">        <span class="keyword">self</span>._items[i], <span class="keyword">self</span>._items[j] = <span class="keyword">self</span>._items[j], <span class="keyword">self</span>._items[i]</span><br><span class="line"></span><br><span class="line">    def swim(<span class="keyword">self</span>, k):</span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">1</span> and <span class="keyword">self</span>.need_swap(k<span class="comment">//2, k):</span></span><br><span class="line">            <span class="keyword">self</span>.exch(k<span class="comment">//2, k)</span></span><br><span class="line">            k = k<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    def sink(<span class="keyword">self</span>, k):</span><br><span class="line">        <span class="keyword">while</span> <span class="number">2</span> * k &lt;= <span class="keyword">self</span>.length:</span><br><span class="line">            j = <span class="number">2</span> * k</span><br><span class="line">            <span class="keyword">if</span> j &lt; <span class="keyword">self</span>.length and <span class="keyword">self</span>.need_swap(j, j+<span class="number">1</span>):</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> not <span class="keyword">self</span>.need_swap(k, j):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">self</span>.exch(k, j)</span><br><span class="line">            k = j</span><br><span class="line"></span><br><span class="line">    def insert(<span class="keyword">self</span>, val):</span><br><span class="line">        <span class="keyword">self</span>._items.append(val)</span><br><span class="line">        <span class="keyword">self</span>.swim(<span class="keyword">self</span>.length)</span><br><span class="line"></span><br><span class="line">    def top(<span class="keyword">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.length &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>._items[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    def del_top(<span class="keyword">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.length &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">self</span>.exch(<span class="number">1</span>, <span class="keyword">self</span>.length)</span><br><span class="line">            val = <span class="keyword">self</span>._items.pop()</span><br><span class="line">            <span class="keyword">self</span>.sink(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line">    def __repr__(<span class="keyword">self</span>):</span><br><span class="line">        tmp = []</span><br><span class="line">        seq = <span class="string">' '</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="keyword">self</span>.depth+<span class="number">1</span>):</span><br><span class="line">            l = seq.join([<span class="built_in">str</span>(e) <span class="keyword">for</span> e <span class="keyword">in</span> <span class="keyword">self</span>._items[<span class="number">2</span>**(i-<span class="number">1</span>):<span class="number">2</span>**i]])</span><br><span class="line">            tmp.append(l)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'\n'</span>.join(tmp)</span><br><span class="line"></span><br><span class="line">class Node:</span><br><span class="line">    def __init__(<span class="keyword">self</span>, key, val=<span class="literal">None</span>):</span><br><span class="line">        <span class="keyword">self</span>.key = key</span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">        <span class="keyword">self</span>.count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    def __gt__(<span class="keyword">self</span>, other):</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">self</span>.count &gt; other.count</span><br><span class="line"></span><br><span class="line">    def __repr__(<span class="keyword">self</span>):</span><br><span class="line">        # <span class="keyword">return</span> '&lt;Node key=&#123;!r&#125; val=&#123;!r&#125; count=&#123;!r&#125;&gt;'.format(<span class="keyword">self</span>.key, <span class="keyword">self</span>.val, <span class="keyword">self</span>.count)</span><br><span class="line">        <span class="keyword">return</span> '&#123;&#125;|&#123;!r&#125;'.format(<span class="keyword">self</span>.key, <span class="keyword">self</span>.count)</span><br><span class="line"></span><br><span class="line">class LFUCache:</span><br><span class="line">    def __init__(<span class="keyword">self</span>, size):</span><br><span class="line">        <span class="keyword">self</span>.cache = &#123;&#125;</span><br><span class="line">        <span class="keyword">self</span>.heap = MinHeap()</span><br><span class="line">        <span class="keyword">self</span>.size = size</span><br><span class="line"></span><br><span class="line">    def check_expired(<span class="keyword">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.heap.length == <span class="keyword">self</span>.size:</span><br><span class="line">            node = <span class="keyword">self</span>.heap.del_top()</span><br><span class="line">            <span class="keyword">self</span>.cache.pop(node.key)</span><br><span class="line"></span><br><span class="line">    def update_count(<span class="keyword">self</span>, node):</span><br><span class="line">        idx = <span class="keyword">self</span>.heap._items.index(node)</span><br><span class="line">        node.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">self</span>.heap.sink(idx)</span><br><span class="line"></span><br><span class="line">    def get(<span class="keyword">self</span>, key):</span><br><span class="line">        node = <span class="keyword">self</span>.cache.get(key, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> not node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">self</span>.update_count(node)</span><br><span class="line">        <span class="keyword">return</span> node.val</span><br><span class="line"></span><br><span class="line">    def set(<span class="keyword">self</span>, key, val):</span><br><span class="line">        node = <span class="keyword">self</span>.cache.get(key, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            node.val = val</span><br><span class="line">            <span class="keyword">self</span>.update_count(node)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        node = Node(key, val)</span><br><span class="line">        <span class="keyword">self</span>.check_expired()</span><br><span class="line">        <span class="keyword">self</span>.heap.insert(node)</span><br><span class="line">        <span class="keyword">self</span>.cache[key] = node</span><br><span class="line"></span><br><span class="line">    def __repr__(<span class="keyword">self</span>):</span><br><span class="line">        <span class="keyword">return</span> '&lt;LFU &#123;!r&#125;&gt;'.format(<span class="keyword">self</span>.cache)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://en.wikipedia.org/wiki/Least_frequently_used" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Least_frequently_used</a></li><li><a href="https://melonshell.github.io/2020/02/07/ds_cache_eli/" target="_blank" rel="noopener">https://melonshell.github.io/2020/02/07/ds_cache_eli/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Least Frequently Used (LFU) 是一种常见的缓存淘汰算法，译为“最近最不经常使用”，也就是将缓存中使用次数最少的数据淘汰掉。&lt;/p&gt;
&lt;p&gt;有两种常见的实现方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小顶堆 + hashmap，插入和删除的复杂度为O(logN), 但淘汰相同访问次数的节点是不稳定的，因为堆排序不稳定。&lt;/li&gt;
&lt;li&gt;数组存储数据项 + hashmap记录数据项index, 淘汰缓存的复杂度为O(N)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://ponder.work/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://ponder.work/tags/Python/"/>
    
      <category term="缓存" scheme="http://ponder.work/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>学海屠魔录</title>
    <link href="http://ponder.work/2021/06/20/learning-method/"/>
    <id>http://ponder.work/2021/06/20/learning-method/</id>
    <published>2021-06-20T03:17:00.000Z</published>
    <updated>2021-07-15T08:02:44.041Z</updated>
    
    <content type="html"><![CDATA[<p>英彦有云，魔鬼在细节之中（The devil is in the details），其意义在于提醒人们，不要忽视细节，即使是微不足道的小处也可以影响大局。</p><p>换个角度思考，这句话用在学习上，是再贴切不过了。当我们接触一个新领域时，其中的每个知识细节，都是魔鬼，稍有不慎就会被魔鬼击败，产生厌学情绪，再起不能。只有除尽这些魔鬼，才能攀上知识的高峰。<br><a id="more"></a></p><p>但光学会这些细节的点还远远不够，你的知识都是僵化的，是零散不成体系的的，难以真正应用。<br>就如将英语单词表背得滚瓜烂熟，倘若不识得语法与文法，断然是写不出文章的。</p><p>总地来说，学习分为两个阶段，“为学日益”和“为道日损”，也就是积累具体细节知识点，然后再将这些知识点进行归纳总结整理，将知识抽象并构建体系。</p><blockquote><p>注：此处的“为学日益”和“为道日损”与道德经中原义不同</p></blockquote><p>华罗庚教授曾把读书的过程归纳为“由薄到厚”与“由厚到薄”两个阶段，也是异曲同工；硅谷钢铁侠马斯克常说的“第一性原理”，就是第二步“为道日损”所得到的结果；再进一步，禅宗所说的“渐修”和“顿悟”也是一样的。</p><p>这两个阶段总体上是同等重要的，但在学习的不同阶段又该有所侧重。</p><p>下面将理论展开论述，我们又能引申出一些结论，得到一些新的看法。</p><h2 id="为学日益"><a href="#为学日益" class="headerlink" title="为学日益"></a>为学日益</h2><p>先讲第一阶段，这一阶段积累具体细节知识点，那么多大规模的知识点可以成为一个细节呢？</p><p>这点因人而异，因当前知识储备而异，评判标准就是能否说出该知识点的定义和用途，如若不能就应该继续往下看构成该知识点的子知识点，直至满足标准为止。</p><p>由此可知，学习是有极限的，当最小的知识点都不能领会时，继续学习就无从谈起了。<br>就如数学，当不能理解<code>1 + 1 = 2</code>时，在这之上构建的一切都与你无缘了。</p><p>所以学习还是要靠智商的，只不过要求极低。</p><p>在这个阶段比较有效的方法有</p><ul><li>不同体系的知识类比迁移，跟已学会的知识联系，便于记忆</li><li>费曼学习法，通过输出的方式，对学会的知识点的掌握程度进行确认。</li></ul><h2 id="为道日损"><a href="#为道日损" class="headerlink" title="为道日损"></a>为道日损</h2><p>当学习到达一定的阶段，就该对知识进行归纳整理，以便进入下一阶段的学习。</p><p>因为人脑所能同时关注的知识点是有上限的，如果不加以归纳整理进行抽象，体现出来就是学了新的忘了旧的。</p><p>日常生活的很多场景都与这个有关，比如人们在争辩的时候经常会扣帽子，这就是一种抽象，降低了受众的认知难度，在传播中是有利的。“xx人偷井盖”，这就是典型的扣帽子，一个地方人何其多，每个人又不一样，贴切地描述出这个整体是非常难的，扣帽子就是舍弃了其他特征，用某几个特征来概括整体，这样带了的坏处就是不准确，失之偏颇。</p><p>这一阶段影响的是对知识的应用，也就是将一系列知识点抽象成一个整体，用于构造其他知识。</p><p>抽象有好的有坏的，知识点的名称就是对其内涵的一种抽象，好的抽象应该是可以望文生义的。就像写代码，好的函数命名应该是表达了函数的用途，也就是对具体实现该函数语句的抽象。</p><p>类比也是一种抽象，而且是一种极其高效的抽象，将具体的细节和已有的知识点关联起来。但类比也是危险的，很容易做出不合适的类比，也就是引喻失义。所以类比更像是方便法门，一条通向“第一性原理”的捷径，有其适用场景，不应该作为“第一性原理”本身牢记。</p><h2 id="歧路"><a href="#歧路" class="headerlink" title="歧路"></a>歧路</h2><p>由此可以看出很多学习的方法其实都走在歧路上。</p><p>如学英语，一味在单词和例句中深挖，最终还是不能流畅的写作交流，这是第二阶段缺失造成的。<br>又如罗辑思维，听他灌输各种大而无当的大道理，只会显得很轻浮，除了增加谈资之外无有用处，这是第一阶段缺失造成的。</p><p>最后，希望我这胡言乱语对读者有些微帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;英彦有云，魔鬼在细节之中（The devil is in the details），其意义在于提醒人们，不要忽视细节，即使是微不足道的小处也可以影响大局。&lt;/p&gt;
&lt;p&gt;换个角度思考，这句话用在学习上，是再贴切不过了。当我们接触一个新领域时，其中的每个知识细节，都是魔鬼，稍有不慎就会被魔鬼击败，产生厌学情绪，再起不能。只有除尽这些魔鬼，才能攀上知识的高峰。&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://ponder.work/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://ponder.work/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="学习方法" scheme="http://ponder.work/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>缓存淘汰算法之LRU</title>
    <link href="http://ponder.work/2021/06/20/lru-cache/"/>
    <id>http://ponder.work/2021/06/20/lru-cache/</id>
    <published>2021-06-20T02:48:00.000Z</published>
    <updated>2021-07-15T08:02:44.043Z</updated>
    
    <content type="html"><![CDATA[<p>说到缓存，就必须先了解下计算机的<strong>存储器层次结构</strong>。</p><p>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。</p><p>计算机系统中的存储设备都被组织成了一个存储器层次结构，从上至下，设备的访问速度越来越慢、容量越来越大，并且越便宜。</p><a id="more"></a><p><img src="http://image.runjf.com/mweb/2021-06-20-16241743798154.jpg" alt="-w727"></p><p>高层的空间速度快容量小，为了充分利用，就必须有个数据替换的规则，决定数据的去留。这就是所谓的<strong>缓存淘汰算法</strong>。</p><p>常见的方法</p><ul><li>先进先出算法（FIFO）：最先进入的内容作为替换对象</li><li>最近最少使用算法（LFU）：最近最少使用的内容作为替换对象</li><li>最久未使用算法（LRU）：最久没有访问的内容作为替换对象</li><li>非最近使用算法（NMRU）：在最近没有使用的内容中随机选择一个作为替换对象</li></ul><h2 id="LRU-原理"><a href="#LRU-原理" class="headerlink" title="LRU 原理"></a>LRU 原理</h2><p>Least Recently used(LRU) 是最常用的缓存淘汰算法，一般译为“最近最少使用”，不太贴切，其实应该是“最不是最近使用”，也就是将最近一次访问时间最远的数据淘汰掉。</p><p>LRU正好体现了时间局部性，也就是，如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。</p><p>既然是缓存自然需要数据结构记录key和value，可以使用hashmap来存储，查询和设置的复杂度为O(1)。</p><p>同时还需要记录数据最近一次访问时间的次序，可以想到用线性结构存储，由于频繁插入删除，可以用链表实现，新数据在头部，老数据在尾部。<br>由于需要频繁删除数据，而单向链表没有记录前驱节点信息，需要遍历链表，复杂度为O(N)，所以使用双向链表。</p><p>具体的原则</p><ul><li>新数据插入到链表头部，并存入hashmap（value为链表节点指针）；</li><li>查找hashmap，当key命中，则将数据移到链表头部；</li><li>当链表满的时候，将链表尾部的数据丢弃，删除hashmap对应key；</li></ul><h3 id="LRU的不足"><a href="#LRU的不足" class="headerlink" title="LRU的不足"></a>LRU的不足</h3><p>当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。</p><p><strong>缓存污染</strong>，是指系统将不常用的数据从内存移到缓存，造成常用数据的挤出，降低了缓存效率的现象。</p><p>常见改进算法有LFU，LRU-K</p><h2 id="Python-实现"><a href="#Python-实现" class="headerlink" title="Python 实现"></a>Python 实现</h2><p>首先需要实现双向链表，引入头节点，并将链表首未连在一起，这样插入和删除的时候就不需要额外判断链表的头部和尾部，简化了实现。</p><p>hashmap则使用Python的dict</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key, val=None)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Node(&#123;!r&#125;, &#123;!r&#125;)'</span>.format(self.key, self.val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoublyLink</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = Node(<span class="string">'root'</span>)</span><br><span class="line">        self.root.prev = self.root</span><br><span class="line">        self.root.next = self.root</span><br><span class="line">        self.length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tail</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.root.prev</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append_head</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.insert_after(self.root, node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append_tail</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.insert_after(self.tail, node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_after</span><span class="params">(self, pos: Node, node)</span>:</span></span><br><span class="line">        pos.next.prev = node</span><br><span class="line">        node.next = pos.next</span><br><span class="line">        pos.next = node</span><br><span class="line">        node.prev = pos</span><br><span class="line">        self.length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        ptr = self.root</span><br><span class="line">        <span class="keyword">while</span> ptr.next != self.root:</span><br><span class="line">            <span class="keyword">if</span> ptr.next.key == key:</span><br><span class="line">                <span class="keyword">return</span> ptr.next</span><br><span class="line">            ptr = ptr.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node == self.root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        node.next.prev = node.prev</span><br><span class="line">        node.prev.next = node.next</span><br><span class="line">        self.length -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">del</span> node</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        tmp = [<span class="string">'Link(len=&#123;&#125;):'</span>.format(self.length)]</span><br><span class="line">        ptr = self.root</span><br><span class="line">        <span class="keyword">while</span> ptr.next != self.root:</span><br><span class="line">            tmp.append(repr(ptr.next))</span><br><span class="line">            ptr = ptr.next</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' -&gt; '</span>.join(tmp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size)</span>:</span></span><br><span class="line">        self.cache = &#123;&#125;</span><br><span class="line">        self.dl = DoublyLink()</span><br><span class="line">        self.size = size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_expired</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.dl.length == self.size:</span><br><span class="line">            self.cache.pop(self.dl.tail.key)</span><br><span class="line">            self.dl.remove(self.dl.tail)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move_to_head</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self.dl.remove(node)</span><br><span class="line">        self.dl.append_head(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        node = self.cache.get(key, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.move_to_head(node)</span><br><span class="line">        <span class="keyword">return</span> node.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, key, val)</span>:</span></span><br><span class="line">        node = self.cache.get(key, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            node.val = val</span><br><span class="line">            self.move_to_head(node)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.check_expired()</span><br><span class="line">        self.cache[key] = self.dl.append_head(Node(key, val))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;LRU maxsize=&#123;&#125;, len=&#123;&#125;&gt; &#123;!r&#125;'</span>.format(self.size, self.dl.length, self.cache)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = LRUCache(<span class="number">2</span>)</span><br><span class="line">    c.set(<span class="string">'a'</span>, <span class="number">1</span>)</span><br><span class="line">    print(c, c.dl)</span><br><span class="line">    c.set(<span class="string">'b'</span>, <span class="number">2</span>)</span><br><span class="line">    print(c, c.dl)</span><br><span class="line">    c.get(<span class="string">'a'</span>)</span><br><span class="line">    print(c, c.dl)</span><br><span class="line">    c.set(<span class="string">'c'</span>, <span class="number">3</span>)</span><br><span class="line">    print(c, c.dl)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>深入理解计算机系统</li><li><a href="https://en.wikipedia.org/wiki/Cache_replacement_policies" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Cache_replacement_policies</a></li><li><a href="https://github.com/python/cpython/blob/7247f6f433846c6e37308a550e8e5eb6be379856/Lib/functools.py#L525" target="_blank" rel="noopener">https://github.com/python/cpython/blob/7247f6f433846c6e37308a550e8e5eb6be379856/Lib/functools.py#L525</a></li><li><a href="https://zhuanlan.zhihu.com/p/76553221" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76553221</a></li><li><a href="https://melonshell.github.io/2020/02/07/ds_cache_eli/" target="_blank" rel="noopener">https://melonshell.github.io/2020/02/07/ds_cache_eli/</a></li><li><a href="https://segmentfault.com/a/1190000018810255" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018810255</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说到缓存，就必须先了解下计算机的&lt;strong&gt;存储器层次结构&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。&lt;/p&gt;
&lt;p&gt;计算机系统中的存储设备都被组织成了一个存储器层次结构，从上至下，设备的访问速度越来越慢、容量越来越大，并且越便宜。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://ponder.work/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://ponder.work/tags/Python/"/>
    
      <category term="缓存" scheme="http://ponder.work/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>囚徒健身笔记</title>
    <link href="http://ponder.work/2021/06/10/convict-conditioning/"/>
    <id>http://ponder.work/2021/06/10/convict-conditioning/</id>
    <published>2021-06-10T04:26:00.000Z</published>
    <updated>2021-07-15T08:02:44.037Z</updated>
    
    <content type="html"><![CDATA[<p>这不是一本教你练出“可爱肌肉”的书，而是一本教你练出能用的力量、极限的力量、生存的力量的书。<br>作者保罗·威德在美国最严酷的监狱中度过了19年，在其中逐渐挖掘出了一套最古老的健身法，在商业社会中早已失传的力量哲学，并凭此成为了地球上最强壮的人之一。</p><p>本文是用于速查囚徒健身”六艺”的手册<br><a id="more"></a></p><h2 id="俯卧撑"><a href="#俯卧撑" class="headerlink" title="俯卧撑"></a>俯卧撑</h2><h3 id="升级表"><a href="#升级表" class="headerlink" title="升级表"></a>升级表</h3><table><thead><tr><th></th><th>名称</th><th>逐步做到</th></tr></thead><tbody><tr><td>第一式</td><td>墙壁俯卧撑</td><td>3 x 50 次</td></tr><tr><td>第二式</td><td>上斜俯卧撑</td><td>3 x 40 次</td></tr><tr><td>第三式</td><td>膝盖俯卧撑</td><td>3 x 30 次</td></tr><tr><td>第四式</td><td>半俯卧撑</td><td>2 x 25 次</td></tr><tr><td>第五式</td><td>标准俯卧撑</td><td>2 x 20 次</td></tr><tr><td>第六式</td><td>窄距俯卧撑</td><td>2 x 20 次</td></tr><tr><td>第七式</td><td>偏重俯卧撑</td><td>2 x 20 次</td></tr><tr><td>第八式</td><td>单臂半俯卧撑</td><td>2 x 20 次</td></tr><tr><td>第九式</td><td>杠杆俯卧撑</td><td>2 x 20 次</td></tr><tr><td>最终式</td><td>单臂俯卧撑</td><td>1 x 100 次</td></tr></tbody></table><h3 id="第一式-墙壁俯卧撑"><a href="#第一式-墙壁俯卧撑" class="headerlink" title="第一式 墙壁俯卧撑"></a>第一式 墙壁俯卧撑</h3><p><img src="/media/2021-06-12-16233763110637.jpg" alt><br><img src="/media/2021-06-12-16233763151918.jpg" alt></p><h3 id="第二式-上斜俯卧撑"><a href="#第二式-上斜俯卧撑" class="headerlink" title="第二式 上斜俯卧撑"></a>第二式 上斜俯卧撑</h3><p><img src="/media/2021-06-12-16233763579987.jpg" alt><br><img src="/media/2021-06-12-16233763621816.jpg" alt></p><h3 id="第三式-膝盖俯卧撑"><a href="#第三式-膝盖俯卧撑" class="headerlink" title="第三式 膝盖俯卧撑"></a>第三式 膝盖俯卧撑</h3><p><img src="/media/2021-06-12-16233763890571.jpg" alt><br><img src="/media/2021-06-12-16233763946028.jpg" alt></p><h3 id="第四式-半俯卧撑"><a href="#第四式-半俯卧撑" class="headerlink" title="第四式 半俯卧撑"></a>第四式 半俯卧撑</h3><p><img src="/media/2021-06-12-16233764161292.jpg" alt><br><img src="/media/2021-06-12-16233764200771.jpg" alt></p><h3 id="第五式-标准俯卧撑"><a href="#第五式-标准俯卧撑" class="headerlink" title="第五式 标准俯卧撑"></a>第五式 标准俯卧撑</h3><p><img src="/media/2021-06-12-16233764425831.jpg" alt><br><img src="/media/2021-06-12-16233764478111.jpg" alt></p><h3 id="第六式-窄距俯卧撑"><a href="#第六式-窄距俯卧撑" class="headerlink" title="第六式 窄距俯卧撑"></a>第六式 窄距俯卧撑</h3><p><img src="/media/2021-06-12-16233769560037.jpg" alt><br><img src="/media/2021-06-12-16233769605101.jpg" alt></p><h3 id="第七式-偏重俯卧撑"><a href="#第七式-偏重俯卧撑" class="headerlink" title="第七式 偏重俯卧撑"></a>第七式 偏重俯卧撑</h3><p><img src="/media/2021-06-12-16233769968660.jpg" alt><br><img src="/media/2021-06-12-16233770012414.jpg" alt></p><h3 id="第八式-单臂半俯卧撑"><a href="#第八式-单臂半俯卧撑" class="headerlink" title="第八式 单臂半俯卧撑"></a>第八式 单臂半俯卧撑</h3><p><img src="/media/2021-06-12-16233770432550.jpg" alt><br><img src="/media/2021-06-12-16233770509249.jpg" alt></p><h3 id="第九式-杠杆俯卧撑"><a href="#第九式-杠杆俯卧撑" class="headerlink" title="第九式 杠杆俯卧撑"></a>第九式 杠杆俯卧撑</h3><p><img src="/media/2021-06-12-16233770802445.jpg" alt><br><img src="/media/2021-06-12-16233770843751.jpg" alt></p><h3 id="最终式-单臂俯卧撑"><a href="#最终式-单臂俯卧撑" class="headerlink" title="最终式 单臂俯卧撑"></a>最终式 单臂俯卧撑</h3><p><img src="/media/2021-06-12-16233771031421.jpg" alt><br><img src="/media/2021-06-12-16233771091907.jpg" alt></p><h2 id="深蹲"><a href="#深蹲" class="headerlink" title="深蹲"></a>深蹲</h2><h3 id="升级表-1"><a href="#升级表-1" class="headerlink" title="升级表"></a>升级表</h3><table><thead><tr><th></th><th>名称</th><th>逐步做到</th></tr></thead><tbody><tr><td>第一式</td><td>肩倒立深蹲</td><td>3 x 50 次</td></tr><tr><td>第二式</td><td>折刀深蹲</td><td>3 x 40 次</td></tr><tr><td>第三式</td><td>支撑深蹲</td><td>3 x 30 次</td></tr><tr><td>第四式</td><td>半深蹲</td><td>2 x 50 次</td></tr><tr><td>第五式</td><td>标准深蹲</td><td>2 x 30 次</td></tr><tr><td>第六式</td><td>窄距深蹲</td><td>2 x 20 次</td></tr><tr><td>第七式</td><td>偏重深蹲</td><td>2 x 20 次</td></tr><tr><td>第八式</td><td>单腿半深蹲</td><td>2 x 20 次</td></tr><tr><td>第九式</td><td>单腿辅助深蹲</td><td>2 x 20 次</td></tr><tr><td>最终式</td><td>单腿深蹲</td><td>2 x 50 次</td></tr></tbody></table><h3 id="第一式-肩倒立深蹲"><a href="#第一式-肩倒立深蹲" class="headerlink" title="第一式 肩倒立深蹲"></a>第一式 肩倒立深蹲</h3><p><img src="/media/2021-06-12-16233772675490.jpg" alt><br><img src="/media/2021-06-12-16233772719098.jpg" alt></p><h3 id="第二式-折刀深蹲"><a href="#第二式-折刀深蹲" class="headerlink" title="第二式 折刀深蹲"></a>第二式 折刀深蹲</h3><p><img src="/media/2021-06-12-16233772955163.jpg" alt><br><img src="/media/2021-06-12-16233772994497.jpg" alt></p><h3 id="第三式-支撑深蹲"><a href="#第三式-支撑深蹲" class="headerlink" title="第三式 支撑深蹲"></a>第三式 支撑深蹲</h3><p><img src="/media/2021-06-12-16233773213387.jpg" alt><br><img src="/media/2021-06-12-16233773261167.jpg" alt></p><h3 id="第四式-半深蹲"><a href="#第四式-半深蹲" class="headerlink" title="第四式 半深蹲"></a>第四式 半深蹲</h3><p><img src="/media/2021-06-12-16233773506567.jpg" alt><br><img src="/media/2021-06-12-16233773550078.jpg" alt></p><h3 id="第五式-标准深蹲"><a href="#第五式-标准深蹲" class="headerlink" title="第五式 标准深蹲"></a>第五式 标准深蹲</h3><p><img src="/media/2021-06-12-16233773844689.jpg" alt><br><img src="/media/2021-06-12-16233773897676.jpg" alt></p><h3 id="第六式-窄距深蹲"><a href="#第六式-窄距深蹲" class="headerlink" title="第六式 窄距深蹲"></a>第六式 窄距深蹲</h3><p><img src="/media/2021-06-12-16233774176578.jpg" alt><br><img src="/media/2021-06-12-16233774216603.jpg" alt></p><h3 id="第七式-偏重深蹲"><a href="#第七式-偏重深蹲" class="headerlink" title="第七式 偏重深蹲"></a>第七式 偏重深蹲</h3><p><img src="/media/2021-06-12-16233774451041.jpg" alt><br><img src="/media/2021-06-12-16233774620446.jpg" alt></p><h3 id="第八式-单腿半深蹲"><a href="#第八式-单腿半深蹲" class="headerlink" title="第八式 单腿半深蹲"></a>第八式 单腿半深蹲</h3><p><img src="/media/2021-06-12-16233774812360.jpg" alt><br><img src="/media/2021-06-12-16233774886667.jpg" alt></p><h3 id="第九式-单腿辅助深蹲"><a href="#第九式-单腿辅助深蹲" class="headerlink" title="第九式 单腿辅助深蹲"></a>第九式 单腿辅助深蹲</h3><p><img src="/media/2021-06-12-16233775041579.jpg" alt><br><img src="/media/2021-06-12-16233775094918.jpg" alt></p><h3 id="最终式-单腿深蹲"><a href="#最终式-单腿深蹲" class="headerlink" title="最终式 单腿深蹲"></a>最终式 单腿深蹲</h3><p><img src="/media/2021-06-12-16233775591993.jpg" alt><br><img src="/media/2021-06-12-16233775633887.jpg" alt></p><h2 id="引体向上"><a href="#引体向上" class="headerlink" title="引体向上"></a>引体向上</h2><h3 id="升级表-2"><a href="#升级表-2" class="headerlink" title="升级表"></a>升级表</h3><table><thead><tr><th></th><th>名称</th><th>逐步做到</th></tr></thead><tbody><tr><td>第一式</td><td>垂直引体</td><td>3 x 40 次</td></tr><tr><td>第二式</td><td>水平引体向上</td><td>3 x 30 次</td></tr><tr><td>第三式</td><td>折刀引体向上</td><td>3 x 20 次</td></tr><tr><td>第四式</td><td>半引体向上</td><td>2 x 15 次</td></tr><tr><td>第五式</td><td>标准引体向上</td><td>2 x 10 次</td></tr><tr><td>第六式</td><td>窄距引体向上</td><td>2 x 10 次</td></tr><tr><td>第七式</td><td>偏重引体向上</td><td>2 x 9 次</td></tr><tr><td>第八式</td><td>单臂半引体向上</td><td>2 x 8 次</td></tr><tr><td>第九式</td><td>单臂辅助引体向上</td><td>2 x 7 次</td></tr><tr><td>最终式</td><td>单臂引体向上</td><td>2 x 6 次</td></tr></tbody></table><h3 id="第一式-垂直引体"><a href="#第一式-垂直引体" class="headerlink" title="第一式 垂直引体"></a>第一式 垂直引体</h3><p><img src="/media/2021-06-12-16235046931778.jpg" alt><br><img src="/media/2021-06-12-16235046978279.jpg" alt></p><h3 id="第二式-水平引体向上"><a href="#第二式-水平引体向上" class="headerlink" title="第二式 水平引体向上"></a>第二式 水平引体向上</h3><p><img src="/media/2021-06-12-16235047167487.jpg" alt><br><img src="/media/2021-06-12-16235047206632.jpg" alt></p><h3 id="第三式-折刀引体向上"><a href="#第三式-折刀引体向上" class="headerlink" title="第三式 折刀引体向上"></a>第三式 折刀引体向上</h3><p><img src="/media/2021-06-12-16235047427692.jpg" alt><br><img src="/media/2021-06-12-16235047509050.jpg" alt></p><h3 id="第四式-半引体向上"><a href="#第四式-半引体向上" class="headerlink" title="第四式 半引体向上"></a>第四式 半引体向上</h3><p><img src="/media/2021-06-12-16235047741587.jpg" alt><br><img src="/media/2021-06-12-16235047788361.jpg" alt></p><h3 id="第五式-标准引体向上"><a href="#第五式-标准引体向上" class="headerlink" title="第五式 标准引体向上"></a>第五式 标准引体向上</h3><p><img src="/media/2021-06-12-16235050886345.jpg" alt><br><img src="/media/2021-06-12-16235050937641.jpg" alt></p><h3 id="第六式-窄距引体向上"><a href="#第六式-窄距引体向上" class="headerlink" title="第六式 窄距引体向上"></a>第六式 窄距引体向上</h3><p><img src="/media/2021-06-12-16235052213410.jpg" alt><br><img src="/media/2021-06-12-16235052268650.jpg" alt></p><h3 id="第七式-偏重引体向上"><a href="#第七式-偏重引体向上" class="headerlink" title="第七式 偏重引体向上"></a>第七式 偏重引体向上</h3><p><img src="/media/2021-06-12-16235052582706.jpg" alt><br><img src="/media/2021-06-12-16235052625014.jpg" alt></p><h3 id="第八式-单臂半引体向上"><a href="#第八式-单臂半引体向上" class="headerlink" title="第八式 单臂半引体向上"></a>第八式 单臂半引体向上</h3><p><img src="/media/2021-06-12-16235052816468.jpg" alt><br><img src="/media/2021-06-12-16235052856461.jpg" alt></p><h3 id="第九式-单臂辅助引体向上"><a href="#第九式-单臂辅助引体向上" class="headerlink" title="第九式 单臂辅助引体向上"></a>第九式 单臂辅助引体向上</h3><p><img src="/media/2021-06-12-16235053207198.jpg" alt><br><img src="/media/2021-06-12-16235053249302.jpg" alt></p><h3 id="最终式-单臂引体向上"><a href="#最终式-单臂引体向上" class="headerlink" title="最终式 单臂引体向上"></a>最终式 单臂引体向上</h3><p><img src="/media/2021-06-12-16235056128115.jpg" alt><br><img src="/media/2021-06-12-16235056169086.jpg" alt></p><h2 id="举腿"><a href="#举腿" class="headerlink" title="举腿"></a>举腿</h2><h3 id="升级表-3"><a href="#升级表-3" class="headerlink" title="升级表"></a>升级表</h3><table><thead><tr><th></th><th>名称</th><th>逐步做到</th></tr></thead><tbody><tr><td>第一式</td><td>坐姿屈膝</td><td>3 x 40 次</td></tr><tr><td>第二式</td><td>平卧抬膝</td><td>3 x 35 次</td></tr><tr><td>第三式</td><td>平卧屈举腿</td><td>3 x 30 次</td></tr><tr><td>第四式</td><td>平卧蛙举腿</td><td>2 x 25 次</td></tr><tr><td>第五式</td><td>平卧直举腿</td><td>2 x 20 次</td></tr><tr><td>第六式</td><td>悬垂屈膝</td><td>2 x 15 次</td></tr><tr><td>第七式</td><td>悬垂屈举腿</td><td>2 x 15 次</td></tr><tr><td>第八式</td><td>悬垂蛙举腿</td><td>2 x 15 次</td></tr><tr><td>第九式</td><td>悬垂半举腿</td><td>2 x 15 次</td></tr><tr><td>最终式</td><td>悬垂直举腿</td><td>2 x 30 次</td></tr></tbody></table><h3 id="第一式-坐姿屈膝"><a href="#第一式-坐姿屈膝" class="headerlink" title="第一式 坐姿屈膝"></a>第一式 坐姿屈膝</h3><p><img src="/media/2021-06-12-16235058330516.jpg" alt><br><img src="/media/2021-06-12-16235058387786.jpg" alt></p><h3 id="第二式-平卧抬膝"><a href="#第二式-平卧抬膝" class="headerlink" title="第二式 平卧抬膝"></a>第二式 平卧抬膝</h3><p><img src="/media/2021-06-12-16235058715628.jpg" alt><br><img src="/media/2021-06-12-16235058987367.jpg" alt></p><h3 id="第三式-平卧屈举腿"><a href="#第三式-平卧屈举腿" class="headerlink" title="第三式 平卧屈举腿"></a>第三式 平卧屈举腿</h3><p><img src="/media/2021-06-12-16235059377778.jpg" alt><br><img src="/media/2021-06-12-16235059420733.jpg" alt></p><h3 id="第四式-平卧蛙举腿"><a href="#第四式-平卧蛙举腿" class="headerlink" title="第四式 平卧蛙举腿"></a>第四式 平卧蛙举腿</h3><p><img src="/media/2021-06-12-16235059751819.jpg" alt><br><img src="/media/2021-06-12-16235059808055.jpg" alt><br><img src="/media/2021-06-12-16235059845183.jpg" alt></p><h3 id="第五式-平卧直举腿"><a href="#第五式-平卧直举腿" class="headerlink" title="第五式 平卧直举腿"></a>第五式 平卧直举腿</h3><p><img src="/media/2021-06-12-16235060043259.jpg" alt><br><img src="/media/2021-06-12-16235060079971.jpg" alt></p><h3 id="第六式-悬垂屈膝"><a href="#第六式-悬垂屈膝" class="headerlink" title="第六式 悬垂屈膝"></a>第六式 悬垂屈膝</h3><p><img src="/media/2021-06-12-16235060276364.jpg" alt><br><img src="/media/2021-06-12-16235060318027.jpg" alt></p><h3 id="第七式-悬垂屈举腿"><a href="#第七式-悬垂屈举腿" class="headerlink" title="第七式 悬垂屈举腿"></a>第七式 悬垂屈举腿</h3><p><img src="/media/2021-06-12-16235060762848.jpg" alt><br><img src="/media/2021-06-12-16235060798627.jpg" alt></p><h3 id="第八式-悬垂蛙举腿"><a href="#第八式-悬垂蛙举腿" class="headerlink" title="第八式 悬垂蛙举腿"></a>第八式 悬垂蛙举腿</h3><p><img src="/media/2021-06-12-16235061418479.jpg" alt><br><img src="/media/2021-06-12-16235061459126.jpg" alt></p><h3 id="第九式-悬垂半举腿"><a href="#第九式-悬垂半举腿" class="headerlink" title="第九式 悬垂半举腿"></a>第九式 悬垂半举腿</h3><p><img src="/media/2021-06-12-16235061942966.jpg" alt><br><img src="/media/2021-06-12-16235061990087.jpg" alt></p><h3 id="最终式-悬垂直举腿"><a href="#最终式-悬垂直举腿" class="headerlink" title="最终式 悬垂直举腿"></a>最终式 悬垂直举腿</h3><p><img src="/media/2021-06-12-16235062300592.jpg" alt><br><img src="/media/2021-06-12-16235062342441.jpg" alt></p><h2 id="桥"><a href="#桥" class="headerlink" title="桥"></a>桥</h2><h3 id="升级表-4"><a href="#升级表-4" class="headerlink" title="升级表"></a>升级表</h3><table><thead><tr><th></th><th>名称</th><th>逐步做到</th></tr></thead><tbody><tr><td>第一式</td><td>短桥</td><td>3 x 50 次</td></tr><tr><td>第二式</td><td>直桥</td><td>3 x 40 次</td></tr><tr><td>第三式</td><td>高低桥</td><td>3 x 30 次</td></tr><tr><td>第四式</td><td>顶桥</td><td>2 x 25 次</td></tr><tr><td>第五式</td><td>半桥</td><td>2 x 20 次</td></tr><tr><td>第六式</td><td>标准桥</td><td>2 x 15 次</td></tr><tr><td>第七式</td><td>下行桥</td><td>2 x 10 次</td></tr><tr><td>第八式</td><td>上行桥</td><td>2 x 8 次</td></tr><tr><td>第九式</td><td>合桥</td><td>2 x 6 次</td></tr><tr><td>最终式</td><td>铁板桥</td><td>2 x 30 次</td></tr></tbody></table><h3 id="第一式-短桥"><a href="#第一式-短桥" class="headerlink" title="第一式 短桥"></a>第一式 短桥</h3><p><img src="/media/2021-06-12-16235063290015.jpg" alt><br><img src="/media/2021-06-12-16235063328476.jpg" alt></p><h3 id="第二式-直桥"><a href="#第二式-直桥" class="headerlink" title="第二式 直桥"></a>第二式 直桥</h3><p><img src="/media/2021-06-12-16235063942389.jpg" alt><br><img src="/media/2021-06-12-16235064080533.jpg" alt></p><h3 id="第三式-高低桥"><a href="#第三式-高低桥" class="headerlink" title="第三式 高低桥"></a>第三式 高低桥</h3><p><img src="/media/2021-06-12-16235064277856.jpg" alt><br><img src="/media/2021-06-12-16235064317107.jpg" alt></p><h3 id="第四式-顶桥"><a href="#第四式-顶桥" class="headerlink" title="第四式 顶桥"></a>第四式 顶桥</h3><p><img src="/media/2021-06-12-16235064592857.jpg" alt><br><img src="/media/2021-06-12-16235064626259.jpg" alt></p><h3 id="第五式-半桥"><a href="#第五式-半桥" class="headerlink" title="第五式 半桥"></a>第五式 半桥</h3><p><img src="/media/2021-06-12-16235065659440.jpg" alt><br><img src="/media/2021-06-12-16235065703449.jpg" alt></p><h3 id="第六式-标准桥"><a href="#第六式-标准桥" class="headerlink" title="第六式 标准桥"></a>第六式 标准桥</h3><p><img src="/media/2021-06-12-16235066089725.jpg" alt><br><img src="/media/2021-06-12-16235066129116.jpg" alt></p><h3 id="第七式-下行桥"><a href="#第七式-下行桥" class="headerlink" title="第七式 下行桥"></a>第七式 下行桥</h3><p><img src="/media/2021-06-12-16235066913378.jpg" alt></p><h3 id="第八式-上行桥"><a href="#第八式-上行桥" class="headerlink" title="第八式 上行桥"></a>第八式 上行桥</h3><p><img src="/media/2021-06-12-16235067177964.jpg" alt></p><h3 id="第九式-合桥"><a href="#第九式-合桥" class="headerlink" title="第九式 合桥"></a>第九式 合桥</h3><p><img src="/media/2021-06-12-16235067415816.jpg" alt></p><h3 id="最终式-铁板桥"><a href="#最终式-铁板桥" class="headerlink" title="最终式 铁板桥"></a>最终式 铁板桥</h3><p><img src="/media/2021-06-12-16235067900645.jpg" alt></p><h2 id="倒立撑"><a href="#倒立撑" class="headerlink" title="倒立撑"></a>倒立撑</h2><h3 id="升级表-5"><a href="#升级表-5" class="headerlink" title="升级表"></a>升级表</h3><table><thead><tr><th></th><th>名称</th><th>逐步做到</th></tr></thead><tbody><tr><td>第一式</td><td>靠墙顶立</td><td>2 分钟</td></tr><tr><td>第二式</td><td>乌鸦式</td><td>1 分钟</td></tr><tr><td>第三式</td><td>靠墙倒立</td><td>2 分钟</td></tr><tr><td>第四式</td><td>半倒立撑</td><td>2 x 20 次</td></tr><tr><td>第五式</td><td>标准倒立撑</td><td>2 x 15 次</td></tr><tr><td>第六式</td><td>窄距倒立撑</td><td>2 x 12 次</td></tr><tr><td>第七式</td><td>偏重倒立撑</td><td>2 x 10 次</td></tr><tr><td>第八式</td><td>单臂半倒立撑</td><td>2 x 8 次</td></tr><tr><td>第九式</td><td>杠杆倒立撑</td><td>2 x 6 次</td></tr><tr><td>最终式</td><td>单臂倒立撑</td><td>2 x 5 次</td></tr></tbody></table><h3 id="第一式-靠墙顶立"><a href="#第一式-靠墙顶立" class="headerlink" title="第一式 靠墙顶立"></a>第一式 靠墙顶立</h3><p><img src="/media/2021-06-12-16235068440926.jpg" alt><br><img src="/media/2021-06-12-16235068489541.jpg" alt></p><h3 id="第二式-乌鸦式"><a href="#第二式-乌鸦式" class="headerlink" title="第二式 乌鸦式"></a>第二式 乌鸦式</h3><p><img src="/media/2021-06-12-16235068745842.jpg" alt></p><h3 id="第三式-靠墙倒立"><a href="#第三式-靠墙倒立" class="headerlink" title="第三式 靠墙倒立"></a>第三式 靠墙倒立</h3><p><img src="/media/2021-06-12-16235068887754.jpg" alt><br><img src="/media/2021-06-12-16235069018339.jpg" alt></p><h3 id="第四式-半倒立撑"><a href="#第四式-半倒立撑" class="headerlink" title="第四式 半倒立撑"></a>第四式 半倒立撑</h3><p><img src="/media/2021-06-12-16235069405758.jpg" alt></p><h3 id="第五式-标准倒立撑"><a href="#第五式-标准倒立撑" class="headerlink" title="第五式 标准倒立撑"></a>第五式 标准倒立撑</h3><p><img src="/media/2021-06-12-16235069592851.jpg" alt></p><h3 id="第六式-窄距倒立撑"><a href="#第六式-窄距倒立撑" class="headerlink" title="第六式 窄距倒立撑"></a>第六式 窄距倒立撑</h3><p><img src="/media/2021-06-12-16235069787787.jpg" alt></p><h3 id="第七式-偏重倒立撑"><a href="#第七式-偏重倒立撑" class="headerlink" title="第七式 偏重倒立撑"></a>第七式 偏重倒立撑</h3><p><img src="/media/2021-06-12-16235069957421.jpg" alt></p><h3 id="第八式-单臂半倒立撑"><a href="#第八式-单臂半倒立撑" class="headerlink" title="第八式 单臂半倒立撑"></a>第八式 单臂半倒立撑</h3><p><img src="/media/2021-06-12-16235070206862.jpg" alt></p><h3 id="第九式-杠杆倒立撑"><a href="#第九式-杠杆倒立撑" class="headerlink" title="第九式 杠杆倒立撑"></a>第九式 杠杆倒立撑</h3><p><img src="/media/2021-06-12-16235070497871.jpg" alt></p><h3 id="最终式-单臂倒立撑"><a href="#最终式-单臂倒立撑" class="headerlink" title="最终式 单臂倒立撑"></a>最终式 单臂倒立撑</h3><p><img src="/media/2021-06-12-16235070847276.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这不是一本教你练出“可爱肌肉”的书，而是一本教你练出能用的力量、极限的力量、生存的力量的书。&lt;br&gt;作者保罗·威德在美国最严酷的监狱中度过了19年，在其中逐渐挖掘出了一套最古老的健身法，在商业社会中早已失传的力量哲学，并凭此成为了地球上最强壮的人之一。&lt;/p&gt;
&lt;p&gt;本文是用于速查囚徒健身”六艺”的手册&lt;br&gt;
    
    </summary>
    
    
      <category term="工作生活" scheme="http://ponder.work/categories/%E5%B7%A5%E4%BD%9C%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="健身" scheme="http://ponder.work/tags/%E5%81%A5%E8%BA%AB/"/>
    
      <category term="GTD" scheme="http://ponder.work/tags/GTD/"/>
    
  </entry>
  
  <entry>
    <title>雪花算法原理及实现</title>
    <link href="http://ponder.work/2021/06/08/snowflake-python-edition/"/>
    <id>http://ponder.work/2021/06/08/snowflake-python-edition/</id>
    <published>2021-06-08T11:48:00.000Z</published>
    <updated>2021-07-15T08:02:44.052Z</updated>
    
    <content type="html"><![CDATA[<p>分布式系统中，全局唯一id的生成是个常见的问题。在互联网的业务系统中，涉及到各种各样的ID，如在支付系统中就会有支付ID、退款ID等。<br><a id="more"></a></p><h2 id="常见ID生成方案"><a href="#常见ID生成方案" class="headerlink" title="常见ID生成方案"></a>常见ID生成方案</h2><h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><p>算法的核心思想是结合机器的网卡、当地时间、一个随记数来生成UUID。</p><ul><li>优点：本地生成，生成简单，性能好，没有高可用风险</li><li>缺点：长度过长，存储冗余，且无序不可读，查询效率低</li></ul><h3 id="数据库自增ID"><a href="#数据库自增ID" class="headerlink" title="数据库自增ID"></a>数据库自增ID</h3><p>使用数据库的id自增策略，如 MySQL 的 auto_increment。并且可以使用两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。</p><ul><li>优点：数据库生成的ID绝对有序，高可用实现方式简单</li><li>缺点：需要独立部署数据库实例，成本高，有性能瓶颈</li></ul><h3 id="Redis生成ID"><a href="#Redis生成ID" class="headerlink" title="Redis生成ID"></a>Redis生成ID</h3><p>Redis的所有命令操作都是单线程的，本身提供像 incr 和 increby 这样的自增原子命令，所以能保证生成的 ID 肯定是唯一有序的。</p><ul><li>优点：不依赖于数据库，灵活方便，且性能优于数据库；数字ID天然排序，对分页或者需要排序的结果很有帮助。</li><li>缺点：如果系统中没有Redis，还需要引入新的组件，增加系统复杂度；需要编码和配置的工作量比较大。</li></ul><h2 id="雪花算法原理"><a href="#雪花算法原理" class="headerlink" title="雪花算法原理"></a>雪花算法原理</h2><p>SnowFlake 算法，是 Twitter 开源的分布式 id 生成算法。</p><p>其核心思想就是：使用一个 64 bit 的 long 型的数字作为全局唯一 id。在分布式系统中的应用十分广泛，且ID 引入了时间戳，保持自增性且不重复。</p><p><img src="http://image.runjf.com/mweb/2021-06-08-16231545423727.jpg" alt></p><p>主要分为 5 个部分：</p><ol><li>1 个 bit：0，无特殊意义，主要是为防止歧义，因为负数的第一位是1。</li><li>41 个 bit：表示的是时间戳，毫秒值，可表示范围0到2^41-1。</li><li>10 个 bit: 代表分区或者机器，可以表示范围0到1024</li><li>12 个 bit：表示分区内的自增序号，可表示范围0到4096</li></ol><p>所以理论上每秒可以生成<code>1000 * 1024 * 4096 = 4194304000</code>个id，完全足够使用</p><h2 id="Python-实现"><a href="#Python-实现" class="headerlink" title="Python 实现"></a>Python 实现</h2><p>有几个需要注意的点</p><ul><li>系统时间可能会不准，要防止时间戳回拨</li><li>分区的10bit也可以进行二次分组，如前2bit代表机房，后8个bit代表机器</li><li>时间戳不一定要存储实际的时间戳，可以存储相对某个时间的变化，更节省空间</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">MAX_WORKER = <span class="number">2</span> ** <span class="number">10</span> - <span class="number">1</span></span><br><span class="line">MAX_SEQ = <span class="number">2</span> ** <span class="number">12</span> - <span class="number">1</span></span><br><span class="line">TIME_OFFSET = <span class="number">1577808000000</span>  <span class="comment"># datetime.datetime(2020, 1, 1, 0, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnowFlake</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, worker_id)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0</span> &lt;= worker_id &lt; MAX_WORKER</span><br><span class="line">        self._worker_id = int(worker_id)</span><br><span class="line">        self._timestamp = int(time() * <span class="number">1000</span>)</span><br><span class="line">        self._seq = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_id</span><span class="params">(self)</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        res |= self._seq</span><br><span class="line">        res |= (self._worker_id &lt;&lt; <span class="number">12</span>)</span><br><span class="line">        res |= ((self._timestamp - TIME_OFFSET) &lt;&lt; <span class="number">22</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next_id</span><span class="params">(self)</span>:</span></span><br><span class="line">        t = int(time() * <span class="number">1000</span>)</span><br><span class="line">        <span class="keyword">assert</span> t &gt;= self._timestamp</span><br><span class="line">        <span class="keyword">assert</span> self._seq &lt; MAX_SEQ</span><br><span class="line">        <span class="keyword">if</span> t &gt; self._timestamp:</span><br><span class="line">            self._timestamp = t</span><br><span class="line">            self._seq = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._seq += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.get_id()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_bin</span><span class="params">(val)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;:0&gt;64&#125;'</span>.format(bin(val)[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sf = SnowFlake(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        print(sf.get_bin(sf.next_id()), sf._timestamp, sf._seq)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://juejin.cn/post/6844903631137800200" target="_blank" rel="noopener">https://juejin.cn/post/6844903631137800200</a></li><li><a href="https://www.cnblogs.com/wuzhenzhao/p/13295382.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuzhenzhao/p/13295382.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式系统中，全局唯一id的生成是个常见的问题。在互联网的业务系统中，涉及到各种各样的ID，如在支付系统中就会有支付ID、退款ID等。&lt;br&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://ponder.work/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://ponder.work/tags/Python/"/>
    
      <category term="分布式" scheme="http://ponder.work/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="算法" scheme="http://ponder.work/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>一致性哈希原理及实现</title>
    <link href="http://ponder.work/2021/06/02/consistent-hashing/"/>
    <id>http://ponder.work/2021/06/02/consistent-hashing/</id>
    <published>2021-06-02T14:48:00.000Z</published>
    <updated>2021-07-15T08:02:44.036Z</updated>
    
    <content type="html"><![CDATA[<p>一致性哈希是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位(slots)数的改变平均只需要对 K/n 个key需要重新映射，其中K是key的数量，n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。</p><p>谈到一致性哈希（Consistent hashing），就得先讲一下分布式存储。<br>比如我们有2000w条数据，一台机器存不下，那么我们可以把分成10份每份200w条存到10台机器上。<br>这样存储就不成问题，但是查询效率很低，查一条数据要每台机器都查一遍。<br>如果这些数据能够分类，每一类存到一台机器上，查询前先知道数据的类别，就可以直接定位到某台机器，效率就高了。<br><a id="more"></a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>那么就得找到一个通用而且均匀的分类方法，可以想到先哈希再取模<code>hash(data) % N</code></p><p>现有这几个数据apple, banana, cherry，durian，希望存储到有3台机器的服务.<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 假设自定义了hash函数，有以下返回</span><br><span class="line">hash(<span class="string">"apple"</span>) % <span class="number">3</span> == <span class="number">30</span> % <span class="number">3</span> == <span class="number">0</span></span><br><span class="line">hash(<span class="string">"banada"</span>) % <span class="number">3</span> == <span class="number">31</span> % <span class="number">3</span> == <span class="number">1</span></span><br><span class="line">hash(<span class="string">"cherry"</span>) % <span class="number">3</span> == <span class="number">32</span> % <span class="number">3</span> == <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p><img src="http://image.runjf.com/mweb/2021-06-03-16226066038043.jpg" alt></p><p>如果B机器宕机了，需要将取模余数和机器重新映射，这时发现3/4的数据都需要迁移<br><img src="http://image.runjf.com/mweb/2021-06-03-16226068389571.jpg" alt></p><p>其实当B机器宕机时，取模的除数可以不改成2，依然是<code>hash(data) % 3</code>，这样余数就不会变，只需要把余数和机器的映射改一下，将原先B机器的映射到A机器上，这样只需要迁移1/4的数据.<br><img src="http://image.runjf.com/mweb/2021-06-03-16226412563166.jpg" alt></p><p>但是现在取模的除数和机器数目相等，只能应对机器减少的情况，增加机器就没法处理了。<br>这时可以<strong>用一个比较大的数作为除数</strong>（比如3000），把除数在一定范围内的都映射到某台机器，增加机器只需要调整余数和机器的映射就行了。<br><img src="http://image.runjf.com/mweb/2021-06-03-16226416942953.jpg" alt></p><p>到这里一致性哈希的基本原理已经介绍完了，但对于新增服务器的情况还存在一些问题。<br>新增的服务器D只分担了C服务器的负载，服务器 A 和 B 并没有因为 D 服务器的加入而减少负载压力。<br>针对这个问题，可以把D当做多台机器，均匀地放置，这样所有机器的负载都得到分担，也就是所谓的引入虚拟节点。<br><img src="http://image.runjf.com/mweb/2021-06-03-16226421634795.jpg" alt></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>下面用Python来实现一致性哈希，这里实现不带虚拟节点的版本。</p><p>代码实现和上文分析，有几点细节有些不同</p><ul><li>简化实现，使用<code>hashlib.sha1</code>作为哈希函数</li><li>取模的除数设置为<code>2^32 - 1</code>，这是C语言中<code>unsiged int</code>的最大取值。</li><li>根据我们的除数，余数的取值空间就是[0, 2^32 - 1], 可以看成一个首位相连的环。</li><li>余数和机器的映射不需要单独维护，只要将机器也哈希和取模，就得到机器在环上的位置。</li><li>机器分布在环上，将余数的取值范围分割成多个区间，每个区间对应一台机器，每台机器负责上一个机器位置到当前机器位置的数据。<br><img src="http://image.runjf.com/mweb/2021-06-03-16226908837252.jpg" alt></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">MASK = <span class="number">2</span> ** <span class="number">32</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myhash</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(hashlib.sha1(string.encode(<span class="string">"utf-8"</span>)).hexdigest(), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pos</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> myhash(obj) % MASK</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, addr)</span>:</span></span><br><span class="line">        self.addr = addr</span><br><span class="line">        self.pos = get_pos(self.addr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> myhash(self.addr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;Server &#123;&#125;; &#123;:,&#125;&gt;'</span>.format(self.addr, self.pos)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashing</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.servers = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_server</span><span class="params">(self, server)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> server <span class="keyword">not</span> <span class="keyword">in</span> self.servers</span><br><span class="line">        self.servers.append(server)</span><br><span class="line">        self.servers.sort(key=<span class="keyword">lambda</span> i: i.pos)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_server</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> len(self.servers) &gt; <span class="number">0</span></span><br><span class="line">        pos = get_pos(key)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.servers:</span><br><span class="line">            <span class="keyword">if</span> i.pos &gt;= pos:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> self.servers[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ch = ConsistentHashing()</span><br><span class="line">    ch.add_server(Server(<span class="string">'192.168.1.1:80'</span>))</span><br><span class="line">    ch.add_server(Server(<span class="string">'192.168.1.2:80'</span>))</span><br><span class="line">    ch.add_server(Server(<span class="string">'192.168.1.3:80'</span>))</span><br><span class="line">    print(ch.servers)</span><br><span class="line">    print(<span class="string">'&#123;:,&#125;'</span>.format(get_pos(<span class="string">'123'</span>)), ch.get_server(<span class="string">'123'</span>))</span><br><span class="line">    print(<span class="string">'&#123;:,&#125;'</span>.format(get_pos(<span class="string">'xxx'</span>)), ch.get_server(<span class="string">'xxx'</span>))</span><br><span class="line">    print(<span class="string">'&#123;:,&#125;'</span>.format(get_pos(<span class="string">'1'</span>)), ch.get_server(<span class="string">'1'</span>))</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://segmentfault.com/a/1190000021199728" target="_blank" rel="noopener">https://segmentfault.com/a/1190000021199728</a></li><li><a href="https://www.jianshu.com/p/528ce5cd7e8f" target="_blank" rel="noopener">https://www.jianshu.com/p/528ce5cd7e8f</a></li><li><a href="https://en.wikipedia.org/wiki/Consistent_hashing" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Consistent_hashing</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一致性哈希是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位(slots)数的改变平均只需要对 K/n 个key需要重新映射，其中K是key的数量，n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。&lt;/p&gt;
&lt;p&gt;谈到一致性哈希（Consistent hashing），就得先讲一下分布式存储。&lt;br&gt;比如我们有2000w条数据，一台机器存不下，那么我们可以把分成10份每份200w条存到10台机器上。&lt;br&gt;这样存储就不成问题，但是查询效率很低，查一条数据要每台机器都查一遍。&lt;br&gt;如果这些数据能够分类，每一类存到一台机器上，查询前先知道数据的类别，就可以直接定位到某台机器，效率就高了。&lt;br&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://ponder.work/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://ponder.work/tags/Python/"/>
    
      <category term="分布式" scheme="http://ponder.work/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="算法" scheme="http://ponder.work/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器原理及实现</title>
    <link href="http://ponder.work/2021/06/01/bloom-filter-python-edition/"/>
    <id>http://ponder.work/2021/06/01/bloom-filter-python-edition/</id>
    <published>2021-06-01T01:48:00.000Z</published>
    <updated>2021-07-15T08:02:44.035Z</updated>
    
    <content type="html"><![CDATA[<p>布隆过滤器（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。</p><p>它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。<br><a id="more"></a></p><h2 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h2><p>如果想判断一个元素是不是在一个集合里，一般想到的是将集合中所有元素保存起来，然后通过比较确定，比如在Python中通过dict来实现。</p><p>使用dict的方案有个局限，就是没办法应用在大规模数据上。</p><p>以英语单词为例，我们有三个单词apple，banana，cherry。</p><p>如果用dict来存的话是, 查询的准确性是100%，空间占用也是100%<br><img src="http://image.runjf.com/mweb/2021-06-01-16225142545801.jpg" alt></p><p>如果我们对准确性要求降低一些，我们可以只记录单词的首字母；<br>首字母不存在dict中的话，该单词不存在，否则有可能存在。<br><img src="http://image.runjf.com/mweb/2021-06-01-16225146416983.jpg" alt></p><p>记录首字母的方法虽然有效，但是由于同首字母的单词很多，只记录首字母准确率太低了。<br>所以我们可以依次记录前2个字母，只有这两个字母都存在，我们才认为该单词存在。<br><img src="http://image.runjf.com/mweb/2021-06-01-16225149337703.jpg" alt></p><p>以此类推，为了提高准确率，我们可以从前2个字母增加到前n个字母。<br>但是也不能太大，太大的话，dict里的每个字母被重复设置的次数过多，准确率反而会下降。</p><p>以上方案还有一个问题，单词中每个字母的分布是很不均匀的，导致准确率对不同的单词也不稳定。<br>可以不直接记录字母，而是对单词应用哈希函数，并将结果按一个数值（比如26）取模，如<code>hash(&#39;apple&#39;) % 26</code>，当做一个单词的一个字母来记录。<br>同时应用多个不同的哈希函数，并记录取模后的值，相当于记录该单词的多个字母。</p><h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><p>根据上文的分析，可以实现Python版本的布隆过滤器。<br>用<a href="/2021/05/31/bitmap-python-edition/">bitmap</a>代替dict，节省空间占用。<br>使用Python内置的<code>hash</code>函数作为哈希函数。<br>哈希前对元素增加不同的后缀再调用，替代理论里的多个不同哈希函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">BIT_SIZE = <span class="number">5000000</span></span><br><span class="line">BYTE_WIDTH = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitMap</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size, fill=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self._array = bytearray((fill <span class="keyword">for</span> _ <span class="keyword">in</span> range(size//BYTE_WIDTH+<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        major, minor = divmod(index, BYTE_WIDTH)</span><br><span class="line">        self._array[major] |= (<span class="number">0b10000000</span> &gt;&gt; minor)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        major, minor = divmod(index, BYTE_WIDTH)</span><br><span class="line">        mask = <span class="number">0b10000000</span> &gt;&gt; minor</span><br><span class="line">        <span class="keyword">return</span> int(self._array[major] &amp; mask == mask)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloomFilter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.bit_array = BitMap(BIT_SIZE)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        point_list = self.get_postions(url)</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> point_list:</span><br><span class="line">            self.bit_array.set(b)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">contains</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        point_list = self.get_postions(url)</span><br><span class="line">        <span class="keyword">return</span> all(self.bit_array.get(i) <span class="keyword">for</span> i <span class="keyword">in</span> point_list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_postions</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [hash(<span class="string">'&#123;&#125;-&#123;&#125;'</span>.format(url, i)) % BIT_SIZE <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">41</span>, <span class="number">48</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    bf = BloomFilter()</span><br><span class="line">    bf.add(<span class="string">'1'</span>)</span><br><span class="line">    print(bf.contains(<span class="string">'1'</span>))</span><br><span class="line">    print(bf.contains(<span class="string">'2'</span>))</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zh.wikipedia.org/wiki/布隆过滤器" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/布隆过滤器</a></li><li><a href="https://www.cnblogs.com/cpselvis/p/6265825.html" target="_blank" rel="noopener">https://www.cnblogs.com/cpselvis/p/6265825.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;布隆过滤器（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。&lt;/p&gt;
&lt;p&gt;它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。&lt;br&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://ponder.work/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://ponder.work/tags/Python/"/>
    
      <category term="数据结构" scheme="http://ponder.work/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Bitmap 原理及实现</title>
    <link href="http://ponder.work/2021/05/31/bitmap-python-edition/"/>
    <id>http://ponder.work/2021/05/31/bitmap-python-edition/</id>
    <published>2021-05-31T13:48:00.000Z</published>
    <updated>2021-07-15T08:02:44.035Z</updated>
    
    <content type="html"><![CDATA[<p>所谓的 Bitmap 其实就是二进制位数组，由于元素是二进制位，每一个元素只占用1个bit，十分节省内存空间。</p><p>每一个bit有0、1两种状态，所以 Bitmap 适合应用于判断是否存在、桶排序（不含重复元素），具体来说可以用bitmap记录ip信息，实现布隆过滤器等等。<br><a id="more"></a></p><h2 id="Bitmap-原理"><a href="#Bitmap-原理" class="headerlink" title="Bitmap 原理"></a>Bitmap 原理</h2><p>Bitmap 可以看成是个二维数组，第一维取出的元素是byte，然后用第二维的index去访问该byte对应的位。</p><p>由于正常访问内存最小的单位的字节，操作具体的位需要位运算。</p><p><img src="http://image.runjf.com/mweb/2021-05-31-16224684372402.jpg" alt></p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p><strong>注意</strong>：这里的位移操作都是逻辑位移</p><p>一个byte有8bit， 设置某个位为1，需要用到<code>按位或 |</code><br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第<span class="number">0</span>个bit： byte |= <span class="number">0b10000000</span></span><br><span class="line">第<span class="number">1</span>个bit： byte |= <span class="number">0b01000000</span></span><br><span class="line">...</span><br><span class="line">第<span class="number">7</span>个bit： byte |= <span class="number">0b00000001</span></span><br><span class="line"></span><br><span class="line">所以：设置byte的第n个bit(n取<span class="number">0</span>到<span class="number">7</span>)： byte |= (<span class="number">0b10000000</span> &gt;&gt; n)</span><br></pre></td></tr></table></figure></p><p>判断某个位是否为1，需要用到<code>按位与 &amp;</code><br>过程和上面类似, 满足<code>byte &amp; (0b10000000 &gt;&gt; n) == (0b10000000 &gt;&gt; n)</code>，则该位为1</p><p>将某个位置为0，需要用到<code>按位与 &amp;</code><br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第<span class="number">0</span>个bit： byte &amp;= <span class="number">0b01111111</span></span><br><span class="line">第<span class="number">1</span>个bit： byte &amp;= <span class="number">0b10111111</span></span><br><span class="line">...</span><br><span class="line">第<span class="number">7</span>个bit： byte &amp;= <span class="number">0b01111110</span></span><br><span class="line"></span><br><span class="line">所以：第n个bit(n取<span class="number">0</span>到<span class="number">7</span>)： byte &amp;= ((<span class="number">0b10000000</span> &gt;&gt; n) ^ <span class="number">0b11111111</span>)</span><br><span class="line">Python中由于没有无符号数，所以算掩码（<span class="number">0b01111111</span>）时不能用按位取反。</span><br></pre></td></tr></table></figure></p><h3 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h3><p>将使用到的掩码设置为常量，性能会更好，这里的实现主要是为了体现思路，便于理解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BYTE_WIDTH = <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitMap</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size, fill=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self._array = bytearray((fill <span class="keyword">for</span> _ <span class="keyword">in</span> range(size//BYTE_WIDTH+<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        major, minor = divmod(index, BYTE_WIDTH)</span><br><span class="line">        self._array[major] |= (<span class="number">0b10000000</span> &gt;&gt; minor)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        major, minor = divmod(index, BYTE_WIDTH)</span><br><span class="line">        mask = <span class="number">0b10000000</span> &gt;&gt; minor</span><br><span class="line">        <span class="keyword">return</span> int(self._array[major] &amp; mask == mask)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        major, minor = divmod(index, BYTE_WIDTH)</span><br><span class="line">        self._array[major] &amp;= ((<span class="number">0b10000000</span> &gt;&gt; minor) ^ <span class="number">0b11111111</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_bin</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join((<span class="string">'&#123;:0&gt;8&#125;'</span>.format(bin(i)[<span class="number">2</span>:]) <span class="keyword">for</span> i <span class="keyword">in</span> self._array))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所谓的 Bitmap 其实就是二进制位数组，由于元素是二进制位，每一个元素只占用1个bit，十分节省内存空间。&lt;/p&gt;
&lt;p&gt;每一个bit有0、1两种状态，所以 Bitmap 适合应用于判断是否存在、桶排序（不含重复元素），具体来说可以用bitmap记录ip信息，实现布隆过滤器等等。&lt;br&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://ponder.work/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://ponder.work/tags/Python/"/>
    
      <category term="数据结构" scheme="http://ponder.work/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>限流算法之漏桶与令牌桶</title>
    <link href="http://ponder.work/2021/05/30/leaky-bucket-and-token-bucket/"/>
    <id>http://ponder.work/2021/05/30/leaky-bucket-and-token-bucket/</id>
    <published>2021-05-30T02:48:00.000Z</published>
    <updated>2021-07-15T08:02:44.041Z</updated>
    
    <content type="html"><![CDATA[<p>后端一个常见且比较让人头疼的问题是服务限流，没有做好限流开始导致单个服务耗时增加，进而影响上下游服务，最终可能导致整个系统被拖垮。</p><p>限流的目的是通过对并发请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队 或等待、降级。<br><a id="more"></a><br>一般使用的限流算法有漏桶（Leaky Bucket）和令牌桶(Token Bucket)。</p><p>这里有个需要注意的点，这两种算法的名称和示意图都是为了便于理解，实现时并不需要一模一样。</p><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p>漏桶作为计量工具（The Leaky Bucket Algorithm as a Meter )时，可以用于流量整形 (Traffic Shaping ) 和流量控制 （Traffic Policing )，漏桶算法的描述如下。</p><ul><li>一个固定容量的漏桶，按照常量固定速率流出水滴。</li><li>如果桶是空的， 则不需流出水滴。</li><li>可以以任意速率流入水滴到漏桶。</li><li>如果流入水滴超出了桶的容量， 则流入的水滴溢出了（被丢弃）。</li></ul><p><img src="http://image.runjf.com/mweb/2021-05-31-16223879750903.jpg" alt="-w962"></p><p>漏桶的关键在于漏出速度恒定，超出的流量会被丢弃，最终请求看起来会是这样，峰值完全被砍掉了，过于粗暴了，适用的场景不多。<br><img src="http://image.runjf.com/mweb/2021-05-31-16223889987592.jpg" alt="-w1308"></p><h3 id="漏桶Python实现"><a href="#漏桶Python实现" class="headerlink" title="漏桶Python实现"></a>漏桶Python实现</h3><p>网上常见的一种实现是用个队列直接存储请求来模拟漏桶，其实大可不必，内存空间占用大而且效率低。</p><p>其实只需要通过一个队列记录请求时间，结合漏桶漏出速率进行计算，然后移动窗口就可以实现漏桶了。</p><p>这里的实现对漏桶进行了简化，漏桶的容量恰好等于单位时间漏出的量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeakyBucket</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, leaky_rate)</span>:</span></span><br><span class="line">        self.leaky_rate = float(leaky_rate)    <span class="comment"># 漏出速度</span></span><br><span class="line">        self._que = []   <span class="comment"># 请求时间队列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._que)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inspect_expired_items</span><span class="params">(self, time: int)</span>:</span></span><br><span class="line">        <span class="string">"""检查已经漏出的请求</span></span><br><span class="line"><span class="string">        args:</span></span><br><span class="line"><span class="string">            time: 上一个时间窗口, 默认是秒</span></span><br><span class="line"><span class="string">        returns:</span></span><br><span class="line"><span class="string">            item_count: 已漏出的请求个数</span></span><br><span class="line"><span class="string">            remaining_time: 第一个未漏出请求的剩余时间</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        volume = self.size()</span><br><span class="line">        item_count, remaining_time = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> log_idx, log_item <span class="keyword">in</span> enumerate(self._que):</span><br><span class="line">            <span class="keyword">if</span> log_item &gt; time:</span><br><span class="line">                item_count = volume - log_idx</span><br><span class="line">                remaining_time = log_item - time</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> item_count, remaining_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">acquire</span><span class="params">(self, block=True)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        args:</span></span><br><span class="line"><span class="string">            block: 是否阻塞直到可以请求</span></span><br><span class="line"><span class="string">        returns:</span></span><br><span class="line"><span class="string">            - 是否可以请求</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        now = time()</span><br><span class="line">        volume = self.size()</span><br><span class="line">        <span class="keyword">if</span> volume &gt;= self.leaky_rate:   <span class="comment"># 容量已满需要清理已漏出请求</span></span><br><span class="line">            pre_tick = now - <span class="number">1</span>  <span class="comment"># 上一个时间窗口, 默认单位为秒</span></span><br><span class="line">            item_count, remaining_time = self.inspect_expired_items(pre_tick)</span><br><span class="line">            <span class="keyword">if</span> item_count &gt;= self.leaky_rate:   <span class="comment"># 上个周期请求已超限</span></span><br><span class="line">                <span class="keyword">if</span> block:</span><br><span class="line">                    sleep(remaining_time)   <span class="comment"># 等到出现一个空位</span></span><br><span class="line">                    print(<span class="string">'Bucket Full, sleep &#123;&#125; seconds'</span>.format(remaining_time))</span><br><span class="line">                    <span class="keyword">return</span> self.acquire()   <span class="comment"># 再次尝试</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            self._que[:volume-item_count] = []    <span class="comment"># 清除上个周期数据</span></span><br><span class="line">        self._que.append(now)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    rate_limiter = LeakyBucket(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">if</span> rate_limiter.acquire(block=<span class="literal">False</span>):</span><br><span class="line">            print(time(), <span class="string">'succ'</span>, i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(time(), <span class="string">'skip'</span>, i)</span><br><span class="line">        sleep(<span class="number">0.2</span>)</span><br></pre></td></tr></table></figure><h2 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h2><p>令牌桶算法，是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。</p><p>令牌桶算法的描述如下。</p><ul><li>假设限制2r/s ，则按照500毫秒的固定速率往桶中添加令牌。 </li><li>桶中最多存放b个令牌， 当桶满时，新添加的令牌被丢弃或拒绝。 </li><li>当一个n个字节的数据包到达，将从桶中删除n个令牌，然后发送请求</li><li>如果桶中的令牌不足n个，则该数据包将被限流（要么丢弃， 要么在缓冲区等待）。</li></ul><p><img src="http://image.runjf.com/mweb/2021-05-31-16223906628083.jpg" alt="-w846"></p><p>由于令牌放置速度恒定，取出速度不限，所以令牌桶的限流是有一定弹性的，能够接受请求的一定波动。</p><p><img src="http://image.runjf.com/mweb/2021-05-31-16223908269384.jpg" alt="-w1288"></p><h3 id="令牌桶Python实现"><a href="#令牌桶Python实现" class="headerlink" title="令牌桶Python实现"></a>令牌桶Python实现</h3><p>通过计算令牌桶容量和产生速率就可以实现令牌桶，并不需要真的实现“把令牌放桶里”和“取出令牌”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TokenBucket</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, tokens, fill_rate)</span>:</span></span><br><span class="line">        self.capacity = float(tokens)   <span class="comment"># 容量</span></span><br><span class="line">        self._tokens = float(tokens)</span><br><span class="line">        self.fill_rate = float(fill_rate)    <span class="comment"># 产生速度</span></span><br><span class="line">        self.timestamp = time()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">consume</span><span class="params">(self, tokens, block=True)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> tokens &lt;= self.capacity, <span class="string">'Attempted to consume &#123;&#125; tokens from a bucket with capacity &#123;&#125;'</span>.format(tokens, self.capacity)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> block <span class="keyword">and</span> tokens &gt; self.tokens:</span><br><span class="line">            deficit = tokens - self._tokens</span><br><span class="line">            delay = deficit / self.fill_rate</span><br><span class="line">            print(<span class="string">'Have &#123;&#125; tokens, need &#123;&#125;; sleeping &#123;&#125; seconds'</span>.format(self._tokens, tokens, delay))</span><br><span class="line">            sleep(delay)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> tokens &lt;= self.tokens:</span><br><span class="line">            self._tokens -= tokens</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tokens</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._tokens &lt; self.capacity:</span><br><span class="line">            now = time()   <span class="comment"># 获取当前时间</span></span><br><span class="line">            delta = self.fill_rate * (now - self.timestamp)   <span class="comment"># 算出这段时间产出的令牌</span></span><br><span class="line">            self._tokens = min(self.capacity, self._tokens + delta)   <span class="comment"># 丢弃超出容量的令牌</span></span><br><span class="line">            self.timestamp = now   <span class="comment"># 更新基准时间</span></span><br><span class="line">        <span class="keyword">return</span> self._tokens</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rate_limit</span><span class="params">(data, bandwidth_or_burst, steady_state_bandwidth=None)</span>:</span></span><br><span class="line">    <span class="comment"># bandwidth_or_burst 令牌桶容量</span></span><br><span class="line">    <span class="comment"># steady_state_bandwidth 令牌产生速度</span></span><br><span class="line">    bandwidth = steady_state_bandwidth <span class="keyword">or</span> bandwidth_or_burst</span><br><span class="line">    rate_limiter = TokenBucket(bandwidth_or_burst, bandwidth)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> thing <span class="keyword">in</span> data:</span><br><span class="line">        rate_limiter.consume(len(str(thing)))</span><br><span class="line">        <span class="keyword">yield</span> thing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    stream = rate_limit(range(<span class="number">10</span>), <span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> stream:</span><br><span class="line">        print(time(), i)</span><br></pre></td></tr></table></figure><p>注意：以上算法都是单机单线程的实现，如果需要多个机器限流则需要将桶的状态通过redis等外部服务来存储。</p><h2 id="令牌桶和漏桶算法对比"><a href="#令牌桶和漏桶算法对比" class="headerlink" title="令牌桶和漏桶算法对比"></a>令牌桶和漏桶算法对比</h2><ul><li>令牌桶是按照<strong>固定速率往桶中添加令牌</strong>，请求是否被处理需要看桶中令牌是否足够，当令牌数减为零时，则拒绝新的请求。</li><li>漏桶则是按照<strong>固定速率流出请求</strong>，流入请求速率任意，当流入的请求数累积到漏桶容量时，则新流入的请求被拒绝。</li><li>令牌桶限制的是平均流入速率（允许突发请求，只要有令牌就可以处理，支持一次拿3个令牌，或4个令牌）， 并允许一定程度的突发流量。</li><li>漏桶限制的是常量流出速率（即流出速率是一个固定常量值，比如都是1的速率流出，而不能一次是1，下次又是2) , 从而平滑突发流入速率。</li><li>令牌桶允许一定程度的突发，而漏桶主要目的是平滑流入速率。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《亿级流量网站架构核心技术》</li><li><a href="https://github.com/vutran1710/PyrateLimiter" target="_blank" rel="noopener">https://github.com/vutran1710/PyrateLimiter</a></li><li><a href="https://gist.github.com/drocco007/6155452" target="_blank" rel="noopener">https://gist.github.com/drocco007/6155452</a></li><li><a href="https://vim0.com/post/interview/" target="_blank" rel="noopener">https://vim0.com/post/interview/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;后端一个常见且比较让人头疼的问题是服务限流，没有做好限流开始导致单个服务耗时增加，进而影响上下游服务，最终可能导致整个系统被拖垮。&lt;/p&gt;
&lt;p&gt;限流的目的是通过对并发请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队 或等待、降级。&lt;br&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://ponder.work/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://ponder.work/tags/Python/"/>
    
      <category term="限流" scheme="http://ponder.work/tags/%E9%99%90%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理 —— ziplist 压缩列表</title>
    <link href="http://ponder.work/2021/05/22/redis-source-code-data-structure-ziplist/"/>
    <id>http://ponder.work/2021/05/22/redis-source-code-data-structure-ziplist/</id>
    <published>2021-05-22T11:48:00.000Z</published>
    <updated>2021-07-15T08:02:44.051Z</updated>
    
    <content type="html"><![CDATA[<p>压缩列表(ziplist)是列表和哈希的底层实现之一，是为尽可能地节约内存而设计的特殊编码双端链表。 当一个列表只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p><p>压缩列表的优点是节省内存，缺点是插入元素的复杂度较高<code>平均O(N)最坏O(N^2)</code>, 但是在小数据量的情况下，这种复杂度也是可以接受的。</p><a id="more"></a><h2 id="ziplist-结构"><a href="#ziplist-结构" class="headerlink" title="ziplist 结构"></a>ziplist 结构</h2><p>压缩列表是由一系列<code>entry</code>组成的结构。<code>entry</code>记录了当前节点的大小和前置节点的大小，所以可以双向插入和遍历。</p><p>ziplist 又4个主要部分组成</p><ul><li>zlbytes: 4字节，表示整个列表占用内存大小</li><li>zltail: 4字节，表示列表尾节点相对列表第一个字节的偏移量</li><li>zllen: 2字节，表示列表元素个数，如果节点个数超出2^16-1则需要遍历列表求出元素个数。</li><li>zlend: 1字节<code>0xFF</code>, 表示列表末尾</li></ul><p>ziplist 结构示例图<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">area        |&lt;<span class="params">----</span> ziplist header <span class="params">----</span>&gt;|&lt;<span class="params">-----------</span> entries <span class="params">-------------</span>&gt;|&lt;-end-&gt;|</span><br><span class="line"></span><br><span class="line">size          4 bytes  4 bytes  2 bytes    ?        ?        ?        ?     1 byte</span><br><span class="line">            +<span class="params">---------</span>+<span class="params">--------</span>+<span class="params">-------</span>+<span class="params">--------</span>+<span class="params">--------</span>+<span class="params">--------</span>+<span class="params">--------</span>+<span class="params">-------</span>+</span><br><span class="line">component   | zlbytes | zltail | zllen | entry1 | entry2 |  <span class="string">...</span>   | entryN | zlend |</span><br><span class="line">            +<span class="params">---------</span>+<span class="params">--------</span>+<span class="params">-------</span>+<span class="params">--------</span>+<span class="params">--------</span>+<span class="params">--------</span>+<span class="params">--------</span>+<span class="params">-------</span>+</span><br><span class="line">                                       ^                          ^        ^</span><br><span class="line">address                                |                          |        |</span><br><span class="line">                                ZIPLIST_ENTRY_HEAD                |   ZIPLIST_ENTRY_END</span><br><span class="line">                                                                  |</span><br><span class="line">                                                        ZIPLIST_ENTRY_TAIL</span><br></pre></td></tr></table></figure></p><p><img src="http://image.runjf.com/mweb/2021-05-22-16216774199505.jpg" alt="-w1224"></p><p>上图我们向ziplist添加了3个entry元素，向list头部插入（redis内部使用时一般向尾部插入），后面会详细解析这些元素。</p><h3 id="ziplist-节点元素"><a href="#ziplist-节点元素" class="headerlink" title="ziplist 节点元素"></a>ziplist 节点元素</h3><p>每个ziplist节点由一下3个部分组成</p><ul><li>prelen: 前一个节点长度，单位为字节</li><li>encoding: 节点的编码类型，</li><li>content: 节点内容，可能是字节数组(c语言字符串去除末尾的\0)或者数组</li></ul><p>之前的3个节点的二进制详情<br><img src="http://image.runjf.com/mweb/2021-05-22-16216773421053.jpg" alt="-w678"></p><p>节点迭代器结构体 zlentry<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlensize;  <span class="comment">// 编码 prevrawlen 所需的字节大小 </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlen;  <span class="comment">// 前置节点的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lensize; <span class="comment">// 编码 len 所需的字节大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;  <span class="comment">// 当前节点值的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> headersize;  <span class="comment">// 当前节点 header 的大小, 等于prevrawlensize + lensize</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding;  <span class="comment">// 当前节点值所使用的编码类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;   <span class="comment">// 指向当前节点的指针，也就是内存entry的prelen字段</span></span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>：zlentry结构体和ziplist中实际存储的entry结构是不一样的，zlentry只是为了遍历时操作entry时便利一些，类似序列化和反序列化。在需要对entry操作时，把对应位置的信息取出存到zlentry结构体中</p><h3 id="prelen"><a href="#prelen" class="headerlink" title="prelen"></a>prelen</h3><p>prelen 记录了以字节为单位的前一个节点长度，有两种情况</p><ol><li>默认占用1字节空间，表示0到253</li><li>如果节点长度大于253，则这个字节就设置为254(0xFE)作为标志位, 随后的4个字节存储实际长度。</li></ol><p>255这个数字为啥舍弃不用呢？因为255已经作为列表结束的标志位，避免出现误导。</p><h3 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h3><p>encoding 记录了当前节点的编码类型，编码时先尝试将内容转成数字，失败则当做字符串处理。</p><p>个人觉得ziplist的精华就在entry的encoding，对让内存的每一个bit都重复表示了信息。</p><p>下表中的0和1表示具体的二进制位, b表示该位置可能为0或者1</p><table><thead><tr><th>编码</th><th>占用空间/字节</th><th>表示类型</th><th>具体含义</th></tr></thead><tbody><tr><td>00bbbbbb</td><td>1</td><td>字节数组</td><td>content的长度为6bit, 也就是0-63</td></tr><tr><td>01bbbbbb bbbbbbbb</td><td>2</td><td>字节数组</td><td>content的长度为14bit, 也就是0-16383</td></tr><tr><td>10000000 bbbbbbbb bbbbbbbb bbbbbbbb bbbbbbbb</td><td>5</td><td>字节数组</td><td>content的长度为32bit, 也就是0-4294967295</td></tr><tr><td>11110001 到 11111101</td><td>1</td><td>数字</td><td>用4个bit直接表示数字0-12， content长度为0</td></tr><tr><td>11111110</td><td>1</td><td>数字</td><td>content为int8_t, 长度2字节</td></tr><tr><td>11000000</td><td>1</td><td>数字</td><td>content为int16_t, 长度2字节</td></tr><tr><td>11010000</td><td>1</td><td>数字</td><td>content为int32_t, 长度4字节</td></tr><tr><td>11100000</td><td>1</td><td>数字</td><td>content为int64_t, 长度8字节</td></tr><tr><td>11110000</td><td>1</td><td>数字</td><td>content为24bit有符号整数, 长度3字节</td></tr></tbody></table><p>可以看到ziplist为了节省内存空间，表示信息时真是细扣到每一个bit，非常高效。<br>但是也有个不足，就是代码变得复杂了。</p><p>由于prelen和encoding和content这3个部分都是变长的，每一次插入和删除元素都得计算列表内存长度的变化。</p><p>而且由于prelen的变长，可能会触发后面所有节点连锁更新prelen的值.<br>本来节点插入时只需要复制一次该节点以后所有节点的内存，这时复杂度为O(n), 触发连锁更新之后，这时候列表的插入复杂度就会变为O(n^2)。</p><h2 id="list插入"><a href="#list插入" class="headerlink" title="list插入"></a>list插入</h2><p>当list底层实现为ziplist时，插入原始的逻辑<br>主要涉及到各种长度和偏移量的计算，比较繁琐</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistInsert(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen) &#123;</span><br><span class="line">    <span class="comment">// 记录当前 ziplist 的长度</span></span><br><span class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen, prevlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">123456789</span>;   <span class="comment">// 默认值，megic num， 便于debug</span></span><br><span class="line">    zlentry entry, tail;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        <span class="comment">// 列表非空，并且 p 正指向列表的其中一个节点</span></span><br><span class="line">        <span class="comment">// 取出 p 所指向节点的信息，并将它保存到 entry 结构中；用 prevlen 变量记录前置节点的长度</span></span><br><span class="line">        entry = zipEntry(p);</span><br><span class="line">        prevlen = entry.prevrawlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 列表为空，或者列表不为空且p正好指向表尾</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            <span class="comment">// 列表不为空且p正好指向表尾，取出表尾节点的长度</span></span><br><span class="line">            prevlen = zipRawEntryLength(ptail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试将s转换为数字类型，并给出content的长度</span></span><br><span class="line">    <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class="line">        <span class="comment">// 转换成数字成功，结果会保存在value中</span></span><br><span class="line">        reqlen = zipIntSize(encoding);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 转换失败</span></span><br><span class="line">        reqlen = slen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算prelen的长度</span></span><br><span class="line">    reqlen += zipPrevEncodeLength(<span class="literal">NULL</span>,prevlen);</span><br><span class="line">    <span class="comment">// 计算encoding和content的长度</span></span><br><span class="line">    reqlen += zipEncodeLength(<span class="literal">NULL</span>,encoding,slen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要新节点不是被添加到列表末端，就需要确认 p 所指向的节点的prelen是否足够大</span></span><br><span class="line">    <span class="comment">// nextdiff 保存了新旧编码之间的字节大小差，如果大于 0，需要进行扩展</span></span><br><span class="line">    nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为重分配空间，该可能会改变 zl 的地址，p指针可能会失效，需要记录 zl 到 p 的偏移量</span></span><br><span class="line">    offset = p-zl;</span><br><span class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class="line">    p = zl+offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        <span class="comment">// 新元素之后还有节点，因为新元素的加入，需要对这些原有节点进行调整</span></span><br><span class="line">        <span class="comment">// 移动现有元素，为新元素的插入空间腾出位置</span></span><br><span class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class="number">-1</span>+nextdiff);</span><br><span class="line">        <span class="comment">// 将新节点的长度编码至后置节点</span></span><br><span class="line">        zipPrevEncodeLength(p+reqlen,reqlen);</span><br><span class="line">        <span class="comment">// 更新到达表尾的偏移量，将新节点的长度也算上</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class="line">        <span class="comment">// 更新zltail</span></span><br><span class="line">        tail = zipEntry(p+reqlen);</span><br><span class="line">        <span class="keyword">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 新元素是新的表尾节点, 更新zltail</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 nextdiff != 0 时，需要级联地更新后续的节点</span></span><br><span class="line">    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) &#123;</span><br><span class="line">        offset = p-zl;</span><br><span class="line">        <span class="comment">// T  = O(N^2)</span></span><br><span class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class="line">        p = zl+offset;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一切搞定，将前置节点的长度写入新节点的 header</span></span><br><span class="line">    p += zipPrevEncodeLength(p,prevlen);</span><br><span class="line">    <span class="comment">// 将节点值的长度写入新节点的 header</span></span><br><span class="line">    p += zipEncodeLength(p,encoding,slen);</span><br><span class="line">    <span class="comment">// 写入节点值</span></span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,s,slen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zipSaveInteger(p,value,encoding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新zllen</span></span><br><span class="line">    ZIPLIST_INCR_LENGTH(zl,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="list底层转换为链表"><a href="#list底层转换为链表" class="headerlink" title="list底层转换为链表"></a>list底层转换为链表</h2><p>判断是不是要把list转换为链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listTypeTryConversion</span><span class="params">(robj *subject, robj *value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确保 subject 为 ZIPLIST 编码</span></span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding != REDIS_ENCODING_ZIPLIST) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sdsEncodedObject(value) &amp;&amp;</span><br><span class="line">        <span class="comment">// 看字符串是否过长</span></span><br><span class="line">        sdslen(value-&gt;ptr) &gt; server.list_max_ziplist_value)</span><br><span class="line">            <span class="comment">// 将编码转换为双端链表</span></span><br><span class="line">            listTypeConvert(subject,REDIS_ENCODING_LINKEDLIST);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listTypeConvert</span><span class="params">(robj *subject, <span class="keyword">int</span> enc)</span> </span>&#123;</span><br><span class="line">    listTypeIterator *li;</span><br><span class="line">    listTypeEntry entry;</span><br><span class="line">    <span class="keyword">if</span> (enc == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        <span class="built_in">list</span> *l = listCreate();</span><br><span class="line">        listSetFreeMethod(l,decrRefCountVoid);</span><br><span class="line">        <span class="comment">// 遍历 ziplist ，并将里面的值全部添加到双端链表中</span></span><br><span class="line">        li = listTypeInitIterator(subject,<span class="number">0</span>,REDIS_TAIL);</span><br><span class="line">        <span class="keyword">while</span> (listTypeNext(li,&amp;entry)) listAddNodeTail(l,listTypeGet(&amp;entry));</span><br><span class="line">        listTypeReleaseIterator(li);</span><br><span class="line">        <span class="comment">// 更新编码</span></span><br><span class="line">        subject-&gt;encoding = REDIS_ENCODING_LINKEDLIST;</span><br><span class="line">        <span class="comment">// 释放原来的 ziplist</span></span><br><span class="line">        zfree(subject-&gt;ptr);</span><br><span class="line">        subject-&gt;ptr = l;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unsupported list conversion"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>redis 3.0 源码</li><li>redis 设计与实现</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;压缩列表(ziplist)是列表和哈希的底层实现之一，是为尽可能地节约内存而设计的特殊编码双端链表。 当一个列表只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。&lt;/p&gt;
&lt;p&gt;压缩列表的优点是节省内存，缺点是插入元素的复杂度较高&lt;code&gt;平均O(N)最坏O(N^2)&lt;/code&gt;, 但是在小数据量的情况下，这种复杂度也是可以接受的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://ponder.work/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Redis" scheme="http://ponder.work/tags/Redis/"/>
    
      <category term="C" scheme="http://ponder.work/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理 —— SDS 简单动态字符串</title>
    <link href="http://ponder.work/2021/05/07/redis-source-code-data-structure-sds/"/>
    <id>http://ponder.work/2021/05/07/redis-source-code-data-structure-sds/</id>
    <published>2021-05-07T11:48:00.000Z</published>
    <updated>2021-07-15T08:02:44.051Z</updated>
    
    <content type="html"><![CDATA[<p>Redis没有直接使用C语言传统的字符串表示，而是自己构建了一种名为简单动态字符串SD S(simple dynamic string)的数据结构 ，并将SDS用作Redis的默认字符串表示。</p><p>Redis内部所有字符串都由SDS来表示，其本质就是动态字节数组，和python的<code>bytearray</code>类似。<br><a id="more"></a></p><h2 id="SDS-实现"><a href="#SDS-实现" class="headerlink" title="SDS 实现"></a>SDS 实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型别名，用于指向 sdshdr 的 buf 属性, 用以和C字符串兼容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存字符串对象的结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度，不包含末尾的\0</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">// 数据空间, 柔性数组, 存储C字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="http://image.runjf.com/mweb/2021-05-07-16203880544303.jpg" alt></p><p>使用SDS时，一般是通过指向buf数组的指针而不是sdshdr，这样相关接口就和C字符串兼容。同时需要使用到len和free相关属性时，通过计算指针偏移来得到sdshdr指针，整体设计比较高效。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="创建新SDS"><a href="#创建新SDS" class="headerlink" title="创建新SDS"></a>创建新SDS</h2><p>创建比较简单，注意buf末尾的<code>\0</code>，以及最后返回的buf指针<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line">    <span class="comment">// 根据是否有初始化内容，选择适当的内存分配方式</span></span><br><span class="line">    <span class="keyword">if</span> (init) &#123;</span><br><span class="line">        <span class="comment">// zmalloc 不初始化所分配的内存</span></span><br><span class="line">        sh = zmalloc(<span class="keyword">sizeof</span>(struct sdshdr)+initlen+<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// zcalloc 将分配的内存全部初始化为 0</span></span><br><span class="line">        sh = zcalloc(<span class="keyword">sizeof</span>(struct sdshdr)+initlen+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 设置初始化长度</span></span><br><span class="line">    sh-&gt;len = initlen;</span><br><span class="line">    <span class="comment">// 新 sds 不预留任何空间</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中</span></span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf, init, initlen);</span><br><span class="line">    <span class="comment">// 以 \0 结尾</span></span><br><span class="line">    sh-&gt;buf[initlen] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="comment">// 返回 buf 部分，而不是整个 sdshdr</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)sh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="容量调整"><a href="#容量调整" class="headerlink" title="容量调整"></a>容量调整</h2><p>既然是动态数组，就会涉及到容量调整。<br>Redis的调整策略，当所需空间小于SDS_MAX_PREALLOC(当前版本是1MB)时是指数增长, 否则线性增长。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></span><br><span class="line">    <span class="comment">// 获取 s 目前的空余空间长度</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line">    <span class="comment">// s 目前的空余空间已经足够，无须再进行扩展，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="comment">// 获取 s 目前已占用空间的长度</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">    <span class="comment">// s 最少需要的长度</span></span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line">    <span class="comment">// 根据新长度，为 s 分配新空间所需的大小</span></span><br><span class="line">    <span class="comment">// 小于SDS_MAX_PREALLOC(当前版本是1MB)时是指数增长, 否则线性增长</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line">    <span class="comment">// 重新调整空间大小</span></span><br><span class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr)+newlen+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 更新 sds 的空余长度</span></span><br><span class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</span><br><span class="line">    <span class="keyword">return</span> newsh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>redis 3.0 源码</li><li>redis 设计与实现</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis没有直接使用C语言传统的字符串表示，而是自己构建了一种名为简单动态字符串SD S(simple dynamic string)的数据结构 ，并将SDS用作Redis的默认字符串表示。&lt;/p&gt;
&lt;p&gt;Redis内部所有字符串都由SDS来表示，其本质就是动态字节数组，和python的&lt;code&gt;bytearray&lt;/code&gt;类似。&lt;br&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://ponder.work/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Redis" scheme="http://ponder.work/tags/Redis/"/>
    
      <category term="C" scheme="http://ponder.work/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理 —— zskiplist 跳跃表</title>
    <link href="http://ponder.work/2021/04/20/redis-source-code-data-structure-zskiplist/"/>
    <id>http://ponder.work/2021/04/20/redis-source-code-data-structure-zskiplist/</id>
    <published>2021-04-20T13:48:00.000Z</published>
    <updated>2021-07-15T08:02:44.052Z</updated>
    
    <content type="html"><![CDATA[<p>跳跃表 （skiplist) 是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的 指针，从而达到快速访问节点的目的。</p><p>跳跃表优点</p><ul><li>表支持平均<code>O(logN)</code>, 最坏<code>O(N)</code>复杂度的节点查找，效率可以和平衡树相当</li><li>通过顺序性操作来批量处理节点</li><li>实现比平衡树要来得更为简单</li></ul><p>因为<code>ziplist</code>内存占用较小，所以Redis使用作为有序集合的初始底层结构。<br>如果一个有序集合包含的元素数量比较多（大于<code>zset-max-ziplist-entries</code>），又或者有序集合中元素的成员是比较长的字符串时（大于<code>zset-max-ziplist-value</code>），Redis就会将其底层结构转换为跳跃表。</p><a id="more"></a><h2 id="zskiplist-数据结构"><a href="#zskiplist-数据结构" class="headerlink" title="zskiplist 数据结构"></a>zskiplist 数据结构</h2><p>跳跃表节点, 其中<code>zskiplistLevel</code>成员是<a href="https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html" target="_blank" rel="noopener">柔性数组</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度，经过的节点数目</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];  <span class="comment">// 柔性数组</span></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure></p><p>跳跃表<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure></p><p><img src="http://image.runjf.com/mweb/2021-04-23-16190066207268.jpg" alt></p><p>所谓跳跃表，就是多层链表（redis中的实现是最多32层）通过额外的链接提高效率，从低层到高层，节点之间的跨度逐渐变大。</p><p>跨度越大则查找效率越高，所以查找时是从高层往底层查找。</p><p>如果节点的最高层高为x，则可以认为该节点就存储在低x层，则表头到该节点的跨度之和为该节点的rank(排位)，所有节点的最大层高为跳跃表层高。</p><h2 id="跳跃表插入节点"><a href="#跳跃表插入节点" class="headerlink" title="跳跃表插入节点"></a>跳跃表插入节点</h2><p>因为跳跃表是多层链表，所以插入节点的关键是找到每一层插入的位置，以及插入位置的跨度变化，还有新节点的跨度计算。</p><p>python 版跳跃表插入实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比较节点大小</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_node_lt</span><span class="params">(node: zskiplistNode, score: float, obj: robj)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> node.score &lt; score:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> (node.score == score <span class="keyword">and</span></span><br><span class="line">        compareStringObjects(node.obj, obj) &lt; <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zslInsert</span><span class="params">(zsl: zskiplist, score: float, obj: robj)</span> -&gt; zskiplistNode:</span></span><br><span class="line">    <span class="comment"># update list记录的是每一层, 新节点需要插入的位置(新节点x的backward节点指针)</span></span><br><span class="line">    update: List[Opt[zskiplistNode]] = [<span class="literal">None</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(ZSKIPLIST_MAXLEVEL)]</span><br><span class="line">    <span class="comment"># rank[i]: 从高到低, 到第i层为止经过的所有node的span总和, 也就是节点的排序</span></span><br><span class="line">    <span class="comment"># 用于计算新节点各层的span, 以及新节点的后继节点各层的span</span></span><br><span class="line">    rank = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(ZSKIPLIST_MAXLEVEL)]</span><br><span class="line">    x = zsl.header</span><br><span class="line">    <span class="comment"># 从高层开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(zsl.level<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        rank[i] = <span class="number">0</span> <span class="keyword">if</span> i == zsl.level<span class="number">-1</span> <span class="keyword">else</span> rank[i+<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 找到每一层x需要插入的位置, 并更新rank</span></span><br><span class="line">        <span class="keyword">while</span> x.level[i].forward <span class="keyword">and</span> _node_lt(x.level[i].forward, score, obj):</span><br><span class="line">            rank[i] += x.level[i].span</span><br><span class="line">            x = x.level[i].forward</span><br><span class="line">        <span class="comment"># 对于每一层i, 新节点会插入到update[i].level[i]之后</span></span><br><span class="line">        update[i] = x</span><br><span class="line">    level = zslRandomLevel()  <span class="comment"># 取一个随机层数, 使zskiplist，每层节点更为均衡</span></span><br><span class="line">    <span class="comment"># 新节点层高增大的情况，更新扩展层的默认跨度</span></span><br><span class="line">    <span class="keyword">if</span> level &gt; zsl.level:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(zsl.level, level):</span><br><span class="line">            rank[i] = <span class="number">0</span></span><br><span class="line">            update[i] = zsl.header</span><br><span class="line">            update[i].level[i].span = zsl.length </span><br><span class="line">        zsl.level = level</span><br><span class="line">    <span class="comment"># 更新节点x和前驱节点已有层的跨度</span></span><br><span class="line">    x = zslCreateNode(level, score, obj)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(level):</span><br><span class="line">        x.level[i].forward = update[i].level[i].forward</span><br><span class="line">        update[i].level[i].forward = x </span><br><span class="line">        x.level[i].span = update[i].level[i].span - (rank[<span class="number">0</span>] - rank[i])  </span><br><span class="line">        update[i].level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span> </span><br><span class="line">    <span class="comment"># 更新前驱节点扩展层的跨度，x节点这些层没有后继节点，所以跨度为0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(level, zsl.level):</span><br><span class="line">        update[i].level[i].span += <span class="number">1</span>  <span class="comment"># type: ignore</span></span><br><span class="line">    <span class="comment"># 设置新节点的后退指针, level[0]才有后退指针</span></span><br><span class="line">    x.backward = <span class="literal">None</span> <span class="keyword">if</span> update[<span class="number">0</span>] == zsl.header <span class="keyword">else</span> update[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> x.level[<span class="number">0</span>].forward:</span><br><span class="line">        x.level[<span class="number">0</span>].forward.backward = x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        zsl.tail = x</span><br><span class="line">    zsl.length += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></p><h2 id="跳跃表查找"><a href="#跳跃表查找" class="headerlink" title="跳跃表查找"></a>跳跃表查找</h2><p>跳跃表的查找则是从高层向低层查找，沿着最高层链表前进；遇到大于目标值的节点，则往下一层，直到找到相等的值为止。</p><p>经过的所有节点的跨度相加即是目标节点的rank。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zslGetRank</span><span class="params">(zsl: zskiplist, score: float, obj: robj)</span> -&gt; int:</span></span><br><span class="line">    rank = <span class="number">0</span></span><br><span class="line">    x = zsl.header</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(zsl.level<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">while</span> x.level[i].forward <span class="keyword">and</span> _node_lt(x.level[i].forward, score, obj):</span><br><span class="line">            rank += x.level[i].span</span><br><span class="line">            x = x.level[i].forward</span><br><span class="line">        <span class="keyword">if</span> x.obj <span class="keyword">and</span> equalStringObjects(x.obj, obj):</span><br><span class="line">            <span class="keyword">return</span> rank</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>查找score=2.0的o2对象的过程<br><img src="http://image.runjf.com/mweb/2021-04-23-16191635872238.jpg" alt></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>redis 3.0 源码</li><li>redis 设计与实现</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跳跃表 （skiplist) 是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的 指针，从而达到快速访问节点的目的。&lt;/p&gt;
&lt;p&gt;跳跃表优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表支持平均&lt;code&gt;O(logN)&lt;/code&gt;, 最坏&lt;code&gt;O(N)&lt;/code&gt;复杂度的节点查找，效率可以和平衡树相当&lt;/li&gt;
&lt;li&gt;通过顺序性操作来批量处理节点&lt;/li&gt;
&lt;li&gt;实现比平衡树要来得更为简单&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为&lt;code&gt;ziplist&lt;/code&gt;内存占用较小，所以Redis使用作为有序集合的初始底层结构。&lt;br&gt;如果一个有序集合包含的元素数量比较多（大于&lt;code&gt;zset-max-ziplist-entries&lt;/code&gt;），又或者有序集合中元素的成员是比较长的字符串时（大于&lt;code&gt;zset-max-ziplist-value&lt;/code&gt;），Redis就会将其底层结构转换为跳跃表。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://ponder.work/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Redis" scheme="http://ponder.work/tags/Redis/"/>
    
      <category term="C" scheme="http://ponder.work/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理 —— dict 字典</title>
    <link href="http://ponder.work/2021/04/17/redis-source-code-data-structure-dict/"/>
    <id>http://ponder.work/2021/04/17/redis-source-code-data-structure-dict/</id>
    <published>2021-04-17T01:48:00.000Z</published>
    <updated>2021-07-15T08:02:44.051Z</updated>
    
    <content type="html"><![CDATA[<p>这是Redis源码阅读系列第一篇文章。</p><p>dict 是 redis 最重要的数据结构，db、hash、以及服务器内部需要用到hashmap的场景都是用dict来实现的。学习 dict 的源码，我们可以学到hashmap的原理及实现。<br><a id="more"></a></p><h2 id="dict-数据结构"><a href="#dict-数据结构" class="headerlink" title="dict 数据结构"></a>dict 数据结构</h2><p>哈希表元素节点<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键，指向SDS(Redis字符串实现)</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">// 值, 联合值, 可以是整数或者指针</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure></p><p>哈希表<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表元素数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小，初始值为4</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值，总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure></p><p>字典<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定操作函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据，保存了需要传给那些类型特定函数的可选参数</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表，ht[1]在rehash的时候使用</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash 索引，当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; </span><br><span class="line">    <span class="comment">// 目前正在运行的安全迭代器的数量</span></span><br><span class="line">    <span class="keyword">int</span> iterators;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></p><p>结构体，储存不同类型字典的操作函数指针，实现了多态<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure></p><p><img src="http://image.runjf.com/mweb/2021-04-18-16187320239054.jpg" alt="-w789"></p><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>redis 的 dict 本质上就是个hashmap，其中的关键是哈希算法。</p><p>哈希函数（英语：Hash function）又称散列算法、散列函数，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值的指纹。</p><p>比如取模函数就是一种最简单的对整数的哈希算法。</p><p>当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用 <a href="https://zh.wikipedia.org/wiki/Murmur%E5%93%88%E5%B8%8C" target="_blank" rel="noopener">MurmurHash2</a> 算法来计算键的哈希值。</p><p>具体求索引的过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求哈希值</span></span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(kO);</span><br><span class="line"><span class="comment">// 根据哈希值和掩码计算出元素节点索引</span></span><br><span class="line">index = hash &amp; dict-&gt;ht[<span class="number">0</span>].sizemask</span><br></pre></td></tr></table></figure><h2 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h2><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突。</p><p>Redis的哈希表使用链地址法（separate chaining) 来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用 next指针构成一个单向链表，被分配到同一个索 引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。</p><p><img src="http://image.runjf.com/mweb/2021-04-18-16187328149108.jpg" alt="-w722"></p><p>还有一种常用的冲突解决办法是再哈希法，就是同时构造多个不同的哈希函数。<br>当H1 = hashfunc1(key) 发生冲突时，再用H2 = hashfunc1(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。</p><h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子（used/size)维持在一个合理的范围之内，程序需要对哈希表的大小进行相应的扩展或者收缩, 这个过程就是rehash。</p><p>Redis对字典的哈希表执行rehash的步骤如下：</p><ol><li>为字典的<code>ht[1]</code>哈希表分配空间</li><li>将保存在<code>ht[0]</code>中的所有键值对rehash到<code>ht[1]</code>上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到<code>ht[1]</code>哈希表的指定位置上</li><li>全部复制完成后，释放<code>ht[0]</code>，将<code>ht[1]</code>设置为<code>ht[0]</code>，重置<code>ht[1]</code></li></ol><h3 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h3><p>所谓渐进式，是指rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。</p><p>由于redis是单线程的, 哈希表里保存的键值对又可能非常多，一次性将这些键值对全部rehash到ht[1]，会导致服务器在一段时间内停止服务。</p><p>所以需要渐进式 rehash，在字典的每个添加、删除 、查找和更新操作的时候，顺便进行部分元素的 rehash（目前实现是rehash一个元素），避免了集中式rehash而带来的庞大计算量。</p><p>rehash 示例代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dictRehash</span><span class="params">(d: rDict, n: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> dictIsRehashing(d):  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> (n):</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> d.ht[<span class="number">0</span>].used == <span class="number">0</span>:  <span class="comment"># rehash 完成了</span></span><br><span class="line">            <span class="keyword">del</span> d.ht[<span class="number">0</span>].table</span><br><span class="line">            d.ht[<span class="number">0</span>] = c_assignment(d.ht[<span class="number">1</span>])</span><br><span class="line">            _dictReset(d.ht[<span class="number">1</span>])</span><br><span class="line">            d.rehashidx = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> d.ht[<span class="number">0</span>].size &gt; d.rehashidx</span><br><span class="line">        <span class="comment"># 找到第一个需要移动的元素</span></span><br><span class="line">        <span class="keyword">while</span> d.ht[<span class="number">0</span>].table[d.rehashidx] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            d.rehashidx += <span class="number">1</span></span><br><span class="line">        de = d.ht[<span class="number">0</span>].table[d.rehashidx]</span><br><span class="line">        <span class="keyword">while</span> de:  <span class="comment"># 移动该元素（包含整个冲突链表）到ht[1]</span></span><br><span class="line">            nextde = de.next</span><br><span class="line">            h = dictHashKey(d, de.key) &amp; d.ht[<span class="number">1</span>].sizemask</span><br><span class="line">            de.next = d.ht[<span class="number">1</span>].table[h]</span><br><span class="line">            d.ht[<span class="number">1</span>].table[h] = de  <span class="comment"># 复制dictEntry元素</span></span><br><span class="line">            d.ht[<span class="number">0</span>].used -= <span class="number">1</span></span><br><span class="line">            d.ht[<span class="number">1</span>].used += <span class="number">1</span></span><br><span class="line">            de = nextde</span><br><span class="line">        d.ht[<span class="number">0</span>].table[d.rehashidx] = <span class="literal">None</span></span><br><span class="line">        d.rehashidx += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>除了渐进式rehash，对于redis的多个db，也会有定时任务进行主动rehash，防止服务器长期没有执行命令时，数据库字典的 rehash 一直没办法完成。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>redis 3.0 源码</li><li>redis 设计与实现</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是Redis源码阅读系列第一篇文章。&lt;/p&gt;
&lt;p&gt;dict 是 redis 最重要的数据结构，db、hash、以及服务器内部需要用到hashmap的场景都是用dict来实现的。学习 dict 的源码，我们可以学到hashmap的原理及实现。&lt;br&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://ponder.work/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Redis" scheme="http://ponder.work/tags/Redis/"/>
    
      <category term="C" scheme="http://ponder.work/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>滴答清单与小米手环6 —— 近乎完美的番茄工作法方案</title>
    <link href="http://ponder.work/2021/04/16/pomodoro-technique-and-mi-band-6/"/>
    <id>http://ponder.work/2021/04/16/pomodoro-technique-and-mi-band-6/</id>
    <published>2021-04-16T04:26:00.000Z</published>
    <updated>2021-07-15T08:02:44.044Z</updated>
    
    <content type="html"><![CDATA[<style type="text/css" rel="stylesheet">img[alt="-w350"] {     width: 350px}</style><p>一直在寻找比较好的番茄工作法工具，但是都不那么满意。</p><p>物理番茄钟，主要问题是不够灵活，比如调整番茄时长，而且不能和GTD清单同步。</p><p>手机app的话，番茄钟结束的提醒声音过于吵闹，特别在公共场合，比如公司或者图书馆；如果静音或者震动的话，又常常感知不到，导致经常关注番茄钟时间，不能集中精力。</p><p>也用过安卓智能手表，但目前番茄工作法相关应用还是很少，没有找到合适的，而且手表续航太短，高强度使用基本得每天充电，心智负担大。</p><p>之前也用过手机番茄app配合手环，通过手环震动提醒番茄钟结束，方法可行，但是通知经常触达不到，体验不好。</p><p>最近<strong>小米手环6</strong>上市了，经过几天摸索，发现配合<strong>滴答清单</strong>的专注功能，以及<strong>小米穿戴</strong>的通知提醒，总体体验挺好，通知也准确，应当是目前最好的番茄工作法方案了。<br><a id="more"></a></p><p>下面讲一下具体如何配置</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol><li><p>小米穿戴app - 我的 - 开启通知相关权限<br><img src="http://image.runjf.com/mweb/2021-04-17-v2-083dc66a6eac131538658e0718197f8a_1440w.jpg" alt="-w350"></p></li><li><p>小米穿戴app - 我的 - 消息通知<br><img src="http://image.runjf.com/mweb/2021-04-17-v2-1456fe9137371ebec9f71507c539893d_1440w.jpg" alt="-w350"></p></li><li><p>小米穿戴app - 我的 - 设备更多设置 - 震动模式 - App通知提醒 - 添加震动模式（可选）<br><img src="http://image.runjf.com/mweb/2021-04-17-v2-ff6418a487908a51642bec98c7a17179_1440w.jpg" alt="-w350"></p></li><li><p>滴答清单app - 番茄专注 - 开始<br><img src="http://image.runjf.com/mweb/2021-04-17-v2-32488091b7f87efd080108626d1f9d1f_1440w.jpg" alt="-w350"></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;style type=&quot;text/css&quot; rel=&quot;stylesheet&quot;&gt;
img[alt=&quot;-w350&quot;] { 
    width: 350px
}
&lt;/style&gt;

&lt;p&gt;一直在寻找比较好的番茄工作法工具，但是都不那么满意。&lt;/p&gt;
&lt;p&gt;物理番茄钟，主要问题是不够灵活，比如调整番茄时长，而且不能和GTD清单同步。&lt;/p&gt;
&lt;p&gt;手机app的话，番茄钟结束的提醒声音过于吵闹，特别在公共场合，比如公司或者图书馆；如果静音或者震动的话，又常常感知不到，导致经常关注番茄钟时间，不能集中精力。&lt;/p&gt;
&lt;p&gt;也用过安卓智能手表，但目前番茄工作法相关应用还是很少，没有找到合适的，而且手表续航太短，高强度使用基本得每天充电，心智负担大。&lt;/p&gt;
&lt;p&gt;之前也用过手机番茄app配合手环，通过手环震动提醒番茄钟结束，方法可行，但是通知经常触达不到，体验不好。&lt;/p&gt;
&lt;p&gt;最近&lt;strong&gt;小米手环6&lt;/strong&gt;上市了，经过几天摸索，发现配合&lt;strong&gt;滴答清单&lt;/strong&gt;的专注功能，以及&lt;strong&gt;小米穿戴&lt;/strong&gt;的通知提醒，总体体验挺好，通知也准确，应当是目前最好的番茄工作法方案了。&lt;br&gt;
    
    </summary>
    
    
      <category term="工作生活" scheme="http://ponder.work/categories/%E5%B7%A5%E4%BD%9C%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="GTD" scheme="http://ponder.work/tags/GTD/"/>
    
      <category term="番茄工作法" scheme="http://ponder.work/tags/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>gmtime 在多线程环境使用引发的 bug</title>
    <link href="http://ponder.work/2021/04/15/gmtime-multi-thread-problem/"/>
    <id>http://ponder.work/2021/04/15/gmtime-multi-thread-problem/</id>
    <published>2021-04-15T13:48:00.000Z</published>
    <updated>2021-07-15T08:02:44.039Z</updated>
    
    <content type="html"><![CDATA[<p>话接<a href="/2021/03/25/xgboost-multi-thread-problem-debug-and-fix/">上文</a>，还是这个 C++ 模型服务，在并发请求的情况下，大概有0.01%的请求部分模型分数不对。定位这种问题，对一个Python程序员来说，真是苦手。还好，经过调整代码不断测试，最终完美解决了问题。</p><a id="more"></a><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>对比数据，可以发现和请求中的某个时间字段有关。关键逻辑代码如下，主要是一个时间差的计算。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string date_str = "2019-01-01 00:00:00";</span></span><br><span class="line"><span class="comment">// string date_appl = "2012-01-01 00:00:00";</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">test_a</span><span class="params">(<span class="built_in">string</span>&amp; date_str, <span class="built_in">string</span>&amp; date_appl, tm&amp; tm_appl)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(date_str.substr(<span class="number">0</span>,<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="keyword">int</span> date_sec;</span><br><span class="line">    ss &gt;&gt; date_sec;  <span class="comment">// stringstream to int </span></span><br><span class="line">    <span class="keyword">time_t</span> ts_date_1 = date_sec + <span class="number">8</span>*<span class="number">3600</span>;</span><br><span class="line">    tm* tm_date = gmtime(&amp;ts_date_1);  <span class="comment">// timestemp to tm </span></span><br><span class="line">    tm_date-&gt;tm_hour = <span class="number">0</span>;</span><br><span class="line">    tm_date-&gt;tm_min = <span class="number">0</span>;</span><br><span class="line">    tm_date-&gt;tm_sec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> seconds = difftime(mktime(&amp;tm_appl), mktime(tm_date)); <span class="comment">// diff timestemp</span></span><br><span class="line">    <span class="keyword">return</span> seconds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据之前的经验，肯定是该函数内部某些操作非线程安全的, 通过google搜索（关键词: gmtime thread safe）和询问朋友，得到以下信息。</p><ul><li>stringstream to int: 这里date_sec变量不存在竞争条件，所以安全</li><li>gmtime: 不安全</li><li>mktime: 时区不变的情况下安全</li><li>difftime: 安全</li></ul><p>bug应该是来自<code>gmtime</code>，该函数返回的是tm结构体指针，指向的是一个 static 结构体，所以不是线程安全，可以用<code>gmtime_r</code>函数替换。</p><p>修改之后<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">test_a</span><span class="params">(<span class="built_in">string</span>&amp; date_str, <span class="built_in">string</span>&amp; date_appl, tm&amp; tm_appl)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(date_str.substr(<span class="number">0</span>,<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="keyword">int</span> date_sec;</span><br><span class="line">    ss &gt;&gt; date_sec;  <span class="comment">// stringstream to int </span></span><br><span class="line">    <span class="keyword">time_t</span> ts_date_1 = date_sec + <span class="number">8</span>*<span class="number">3600</span>;</span><br><span class="line">    tm tm_date;</span><br><span class="line">    gmtime_r(&amp;ts_date_1, &amp;tm_date);</span><br><span class="line">    tm_date.tm_hour = <span class="number">0</span>;</span><br><span class="line">    tm_date.tm_min = <span class="number">0</span>;</span><br><span class="line">    tm_date.tm_sec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> seconds = difftime(mktime(&amp;tm_appl), mktime(&amp;tm_date));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>经过测试，bug得以解决。但是同时发现一个问题，程序的qps下降了1/3。</p><h2 id="QPS下降"><a href="#QPS下降" class="headerlink" title="QPS下降"></a>QPS下降</h2><p>编程测试代码测试对比<code>gmtime_r</code>和<code>gmtime</code>耗时上并没有显著差别。而且如果不调用<code>gmtime_r</code>只声明<code>tm tm_date</code>，qps也是一样下降。</p><p>考虑到这个函数，在服务中调用次数比较多，而且自动变量的栈空间在函数调用时就会分配, tm结构体又比较大，应该对耗时有影响。</p><p>尝试修改<code>tm tm_date</code>为<code>static tm tm_date</code>静态分配内存, qps恢复正常了。<br>但是由于我们需要在多线程环境中使用，最终修改为<code>static thread_local tm tm_date</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://man7.org/linux/man-pages/man3/gmtime.3p.html#DESCRIPTION" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/gmtime.3p.html#DESCRIPTION</a></li><li><a href="https://stackoverflow.com/questions/18355101/is-standard-c-mktime-thread-safe-on-linux#answer-18355323" target="_blank" rel="noopener">https://stackoverflow.com/questions/18355101/is-standard-c-mktime-thread-safe-on-linux#answer-18355323</a></li><li><a href="https://man7.org/linux/man-pages/man3/difftime.3.html#ATTRIBUTES" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/difftime.3.html#ATTRIBUTES</a></li><li><a href="https://softwareengineering.stackexchange.com/questions/195385/understanding-stack-frame-of-function-call-in-c-c#answer-195406" target="_blank" rel="noopener">https://softwareengineering.stackexchange.com/questions/195385/understanding-stack-frame-of-function-call-in-c-c#answer-195406</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;话接&lt;a href=&quot;/2021/03/25/xgboost-multi-thread-problem-debug-and-fix/&quot;&gt;上文&lt;/a&gt;，还是这个 C++ 模型服务，在并发请求的情况下，大概有0.01%的请求部分模型分数不对。定位这种问题，对一个Python程序员来说，真是苦手。还好，经过调整代码不断测试，最终完美解决了问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://ponder.work/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="C++" scheme="http://ponder.work/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>xgboost C++线程安全问题定位与修复</title>
    <link href="http://ponder.work/2021/03/25/xgboost-multi-thread-problem-debug-and-fix/"/>
    <id>http://ponder.work/2021/03/25/xgboost-multi-thread-problem-debug-and-fix/</id>
    <published>2021-03-25T13:48:00.000Z</published>
    <updated>2021-07-15T08:02:44.057Z</updated>
    
    <content type="html"><![CDATA[<p>公司的线上模型服务是基于<code>brpc + xgboost</code>实现的，而xgboost官方是不支持在多线程环境下使用的（1.2.0版本之前）</p><p>这个模型服务已经有两年多了，显然当时用的版本是不支持多线程的，有位同事当时修改了xgboost的源码，解决了多线程的问题，在线上也稳定运行到现在。</p><p>那么，问题来了。最近有个新需求，用到了xgboost的<code>pred_leaf</code>功能，然后就发现并发请求时<code>0.1%</code>的模型结果不对。</p><a id="more"></a><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>调试过程中，首先删除其他模型，排除干扰。然后开关<code>pred_leaf</code>功能批量对比测试，确认当该功能关闭时，模型结果是正常的。</p><p>所以，很有可能<code>pred_leaf</code>参数导致程序走到和之前不同的分支，而这个分支的多线程问题并未修复。</p><p>那么，解决问题的思路就是：确定之前同事修改了什么，找到与pred_leaf相关的函数，尝试做相同修复。</p><h2 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h2><p>首先得确定同事都修改了什么，由于代码历史比较就远了了，而且xgboost的改动并没有加入到git，也没有明显的版本号等标识，这个地方也就比较头疼了。</p><p>唯一能确定的是，xgboost版本的是0.6左右，修改源码时参考了<a href="https://blog.csdn.net/zc02051126/article/details/79427605" target="_blank" rel="noopener">文章</a>。</p><p>所以只能从git下载最新的代码，然后<code>git --no-pager log  --stat</code>查看每个commit的改动情况，使用<code>beyond compared对比 + 人肉二分查找</code>，最终定位到对应的commit。</p><p>找到了对应的commit之后，通过对比改动和结合上文参考文章，其实就是两类改动。</p><ol><li>存在竞争条件的变量 -&gt; 加锁</li><li>不存在竞争条件的变量 -&gt; threadLocal，栈上自动变量</li></ol><p>具体来说，以<code>PredLoopSpecalize</code>为例， 修改前<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">PredLoopSpecalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> nthread = omp_get_max_threads();</span><br><span class="line">    InitThreadTemp(nthread, model.param.num_feature);</span><br><span class="line">    <span class="keyword">for</span> (bst_omp_uint i = <span class="number">0</span>; i &lt; nsize - rest; i += K) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> tid = omp_get_thread_num();</span><br><span class="line">        RegTree::FVec&amp; feats = thread_temp[tid];</span><br><span class="line">        <span class="comment">// thread_temp 为成员变量</span></span><br><span class="line">        <span class="comment">// 省略其他逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">InitThreadTemp</span><span class="params">(<span class="keyword">int</span> nthread, <span class="keyword">int</span> num_feature)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev_thread_temp_size = thread_temp.size();</span><br><span class="line">    <span class="keyword">if</span> (prev_thread_temp_size &lt; nthread) &#123;</span><br><span class="line">      thread_temp.resize(nthread, RegTree::FVec());</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = prev_thread_temp_size; i &lt; nthread; ++i) &#123;</span><br><span class="line">        thread_temp[i].Init(num_feature);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改后<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">PredLoopSpecalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> nthread = omp_get_max_threads();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;RegTree::FVec&gt; local_thread_temp;  <span class="comment">// 改动点</span></span><br><span class="line">    <span class="keyword">int</span> prev_thread_temp_size = local_thread_temp.size();</span><br><span class="line">    <span class="keyword">if</span> (prev_thread_temp_size &lt; nthread) &#123;</span><br><span class="line">      local_thread_temp.resize(nthread, RegTree::FVec());</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = prev_thread_temp_size; i &lt; nthread; ++i) &#123;</span><br><span class="line">        local_thread_temp[i].Init(model.param.num_feature);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (bst_omp_uint i = <span class="number">0</span>; i &lt; nsize - rest; i += K) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> tid = omp_get_thread_num();</span><br><span class="line">        RegTree::FVec&amp; feats = local_thread_temp[tid];  <span class="comment">// 改动点</span></span><br><span class="line">        <span class="comment">// thread_temp 为成员变量</span></span><br><span class="line">        <span class="comment">// 省略其他逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>显然问题就在<code>thread_temp</code>, 做为类成员，它不是线程安全的，通过替换为栈上的<code>local_thread_temp</code>，不同进程访问的地址不同，自然就不存在冲突了。</p><p>通过查找<code>PredLoopSpecalize</code>函数的调用链，可以发现其修改只会影响正常预测，pred_leaf则是不同的分支，显然线程安全的问题依然存在。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用链</span></span><br><span class="line">XGBoosterPredict()</span><br><span class="line">    --&gt; LearnerImpl::Predict()</span><br><span class="line">        --&gt; LearnerImpl::PredictRaw() <span class="comment">// if 正常predict</span></span><br><span class="line">            --&gt; GBTree::PredictBatch()</span><br><span class="line">                --&gt; CPUPredictor::PredictBatch()</span><br><span class="line">                    --&gt; CPUPredictor::PredLoopInternal()</span><br><span class="line">                        --&gt; Dart::PredLoopSpecalize()</span><br><span class="line">        --&gt; GBTree::PredictLeaf()   <span class="comment">// if pred_leaf</span></span><br><span class="line">        --&gt; GBTree::PredictContribution()</span><br><span class="line">        --&gt; ObjFunction::PredTransform()</span><br><span class="line"></span><br><span class="line"><span class="comment">// LearnerImpl::Predict() 源码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Predict</span><span class="params">(DMatrix* data, <span class="keyword">bool</span> output_margin,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;bst_float&gt;* out_preds, <span class="keyword">unsigned</span> ntree_limit,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">bool</span> pred_leaf, <span class="keyword">bool</span> pred_contribs)</span> <span class="keyword">const</span> override </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pred_contribs) &#123;</span><br><span class="line">        gbm_-&gt;PredictContribution(data, out_preds, ntree_limit);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pred_leaf) &#123;</span><br><span class="line">        gbm_-&gt;PredictLeaf(data, out_preds, ntree_limit);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;PredictRaw(data, out_preds, ntree_limit);</span><br><span class="line">        <span class="keyword">if</span> (!output_margin) &#123;</span><br><span class="line">        obj_-&gt;PredTransform(out_preds);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以，最后采用与<code>PredLoopSpecalize</code>相同方法对<code>PredictLeaf</code>进行修复，问题得以完美解决。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>源码版本管理非常重要。</li><li>软件版本在新建项目时尽量选择较新版本，因为后续迭代更新版本的概率较小。</li><li>xgboost建议使用1.2.0以上版本，已经线程安全。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/zc02051126/article/details/79427605" target="_blank" rel="noopener">https://blog.csdn.net/zc02051126/article/details/79427605</a></li><li><a href="https://github.com/dmlc/xgboost" target="_blank" rel="noopener">https://github.com/dmlc/xgboost</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司的线上模型服务是基于&lt;code&gt;brpc + xgboost&lt;/code&gt;实现的，而xgboost官方是不支持在多线程环境下使用的（1.2.0版本之前）&lt;/p&gt;
&lt;p&gt;这个模型服务已经有两年多了，显然当时用的版本是不支持多线程的，有位同事当时修改了xgboost的源码，解决了多线程的问题，在线上也稳定运行到现在。&lt;/p&gt;
&lt;p&gt;那么，问题来了。最近有个新需求，用到了xgboost的&lt;code&gt;pred_leaf&lt;/code&gt;功能，然后就发现并发请求时&lt;code&gt;0.1%&lt;/code&gt;的模型结果不对。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://ponder.work/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://ponder.work/tags/Python/"/>
    
      <category term="机器学习" scheme="http://ponder.work/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="C++" scheme="http://ponder.work/tags/C/"/>
    
  </entry>
  
</feed>
